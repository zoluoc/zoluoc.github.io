<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis5.x版本搭建高可用集群（HA）]]></title>
    <url>%2F2019%2F01%2F16%2FRedis5-x%E7%89%88%E6%9C%AC%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%EF%BC%88HA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[单机环境搭建 单机环境仅供我们平时开发和测试时使用，一般我们可能会在 Linux 或者 Windows 上部署，Windows版本的部署非常简单，首先在 GitHub 上下载 zip 包解压到指定位置，后执行下面的命令就成功的部署好了。下载地址 Redis GitHub 下载地址 12redis-server.exe redis.windows.config` 运行成功如下图 Linux 版本安装如下 1.主机名修改hostnamectl –static set-hostname redis1 2.安装gcc yum install gcc检查是否安装 gcc -v 3.下载 Redis gz 安装包到 Redis 官网下载安装包，也可使用一下命令直接下载到服务器1wget http://download.redis.io/releases/redis-5.0.3.tar.gz #远程下载 下载完成后解压到 /usr/local 目录下修改 /usr/local/redis-5.0.3/redis.conf 参数 daemonize 值改为 yes，使其后台运行，启动命令如下：1/usr/local/redis-5.0.3/src/redis-server /usr/local/redis-5.0.3/redis.conf #指定配置文件 4.验证单机环境 验证启动是否成功 ps -ef | grep redis 进入redis客户端 /usr/local/redis-5.0.3/src/redis-cli 存数据 set name zoluo 取数据 get name 退出客户端 quit 或 Ctrl + C 或 exit 退出redis服务：（1）pkill redis-server（2）kill -9 进程号 高可用集群环境搭建哨兵模式在 Redis3.0 以前的版本要实现集群一般是借助哨兵 sentinel 工具来监控master节点的状态， 如果 master 节点异常，则会做主从切换，将某一台 slave 作为 master，哨兵的配置略微复 杂，并且性能和高可用性等各方面表现一般，特别是在主从切换的瞬间存在访问瞬断的情 况，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发，且单个主节点内存 也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率。参考： Redis 中哨兵sentinel 机制、从宕机及恢复、主库宕机及恢复解决方案 redis哨兵模式高可用集群模式1.概述Redis 的集群主要是使用切片技术来搭建的，简单来说就是把所有KEY分散存放到不同的redis节点上（不要把鸡蛋都放在一个篮子里）。 2.说明Redis 集群是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特 性。Redis 集群不需要 sentinel 哨兵也能完成节点移除和故障转移的功能。需要将每个节点 设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到 上万个节点(官方推荐不超过 1000 个节点)。Redis 集群的性能和高可用性均优于之前版本的 哨兵模式，且集群配置非常简单 。 3.集群基本原理Redis 集群中内置了 16384 个槽位，当需要放置数据时，Redis 先对 KEY 使用 CRC16 算法计算出一个结果，然后把结果对 16384 求余数，这样每个 KEY 都会对应一个编号在 0-16383 之间的槽号码，Redis 会根据节点数量大致均等的原则将哈希槽映射到不同节点。比如有 3 个 Redis 节点，把 16384 分成 3 段，每个节点承担一段范围的哈希槽。在一个集群中16384个槽位必须同时在线否则集群就会失败。 优点是添加和移除节点非常容易。比如要新增一个节点，值需要从其他节点上移动一些槽位到新节点即可，如果要删除一个节点，那就把它拥有的槽位移动到其他节点，然后进行删除。上面这种移动过程不需要任何停机时间。 所有的 Redis 节点彼此互通 节点的失败是通过集群中超过半数的节点检测失效才生效的 客户端与 Redis 节点直连，不需要中间的代理，客户端不需要连接集群所有节点，只需要连接任何一个可用的节点即可 4.Redis 高可用集群搭建Redis 集群需要至少要三个 master 节点，我们这里使用三台虚拟机搭建三个 master 节点，并且给每个 master 再搭建一个slave 节点，总共6个 Redis 节点，这里用三台机器部署6个 Redis 实例，每台机器一主一从，搭建集群的步骤如下： 第一步：在每台机器的 /usr/local 下创建文件夹 redis-cluster，然后在其下面分别创建 2 个文件夹如下123456789101112$redis1mkdir -p /usr/local/redis-cluster mkdir 7001mkdir 7002 $redis2mkdir -p /usr/local/redis-cluster mkdir 7003mkdir 7004 $redis3mkdir -p /usr/local/redis-cluster mkdir 7005mkdir 7006 第二步：把之前的 /usr/local/redis-5.0.3/redis.conf 配置文件 copy 到每个 700* 下，修改如下内容：1234567891011（1）daemonize yes （2）port 7001 #分别对每个机器的端口号进行设置 （3）dir /usr/local/redis-cluster/7001/ #指定数据文件存放位置，必须要指定不同的目录位置，不然会丢失数据（4）cluster-enabled yes #启动集群模式 （5）cluster-config-file nodes-7001.conf #集群节点信息文件，这里 700* 和port对应上 （6）cluster-node-timeout 5000 （7) # bind 127.0.0.1 #去掉bind绑定访问ip信息（8) protected-mode no #关闭保护模式 （9）appendonly yes #如果要设置密码需要增加如下配置： requirepass zoluo #设置redis访问密码 masterauth zoluo #设置集群节点间访问密码，跟上面一致 第三步：另外两台机器修改第2、3、5项里的端口号 第四步：分别启动6个redis实例，然后检查是否启动成功，命令如下12/usr/local/redis-5.0.3/src/redis-server /usr/local/redis-cluster/700*/redis.conf ps -ef | grep redis #查看是否启动成功 第五步：用 redis-cli 创建整个 Redis 集群(Redis 5.x以前的版本集群是依靠 ruby 脚本 redistrib.rb 实现)1/usr/local/redis-5.0.3/src/redis-cli -a sinopec --cluster create --cluster-replicas 1 10.18.2.156:7001 10.18.2.160:7004 10.18.2.160:7003 10.18.2.187:7006 10.18.2.187:7005 10.18.2.156:7002 192.168.0.63:8006 #代表为每个创建的主服务器节点创建一个从服务器节点 第六步：验证集群：（1）连接任意一个客户端即可：12345#./redis-cli -c -h -p (-a访问服务端密码，-c表示集群模 式，指定ip地址和端口号）/usr/local/redis-5.0.3/src/redis-cli -a zoluo-c -h 10.18.2.160 -p 700* cluster infoc #查看集群信息cluster nodes #查看节点列表 #进行数据操作验证 （2）关闭集群则需要逐个进行关闭，使用命令：1/usr/local/redis-5.0.3/src/redis-cli -a zoluo -c -h 10.18.2.160 -p 700* shutdown 自此 Redis 高可用集群搭建完毕！参考：Redis 集群详解Redis 官方说明 补充说明1.Redis 集群节点加入顺序与主节点与从节点关联是随机的，参考官方说明。2.如果在安装过程中出现不可逆转的错误或安装失败，最好重新安装。重新安装我要做关键的两步： 关闭集群 123/usr/local/redis-5.0.3/src/redis-cli -a zoluo -c -h 10.18.2.160 -p 700* shutdown或kill -9 进程号 删除每台机器上数据文件 123cd /usr/local/redis-cluster/700*/rm -rf appendonly.700*.aofrm -rf nodes.700*.conf 重复操作上面 4、5、6 步骤，当然如果需要修改端口，按照每台机器不重复修改就行了。]]></content>
      <categories>
        <category>高可用架构</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Harbor私有仓库搭建]]></title>
    <url>%2F2018%2F12%2F14%2FDocker-Harbor%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[系统环境准备CentOS Linux release 7.4.1708 (Core)docker version：1.13.1docker-compose version 1.21.1, build 5a3f1a3docker-py version: 3.3.0CPython version: 3.6.5OpenSSL version: OpenSSL 1.0.1t 3 May 2016修改主机名，建议修改成 reg.yourdomain.com docker安装安装命令：# yum install docker -y开启docker服务：# systemctl start docker设置docker开启自启动：# chkconfig docker on12# vim /usr/lib/systemd/system/docker.service ExecStart=/usr/bin/dockerd-current --insecure-registry reg.cheng.com \ 重启docker： systemctl daemon-reload &amp;&amp; systemctl restart docker docker-compose安装下载Docker Compose二进制可执行文件1# curl -L https://github.com/docker/compose/releases/download/1.21.1/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose 添加可执行权限1# chmod +x /usr/local/bin/docker-compose OpenSSL安装1# yum -y install openssl openssl-devel 下载harbor离线安装文件12# wget https://storage.googleapis.com/harbor-releases/release-1.5.0/harbor-offline-installer-v1.5.0.tgz# tar zxf harbor-offline-installer-v1.5.0.tgz -C /opt 证书安装12345678# openssl req \ -newkey rsa:4096 -nodes -sha256 -keyout ca.key \ -x509 -days 365 -out ca.crt# openssl req \ -newkey rsa:4096 -nodes -sha256 -keyout yourdomain.com.key \ -out yourdomain.com.csr# openssl x509 -req -days 365 -in yourdomain.com.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out yourdomain.com.crt# cp yourdomain.com.crt /root/cert/# cp yourdomain.com.key /root/cert/# cp ca.crt /etc/docker/certs.d/reg.yourdomain.com# cp yourdomain.com.crt /etc/pki/ca-trust/source/anchors/reg.yourdomain.com.crt# update-ca-trust 配置harbor.cfg文件12345hostname： reg.yourdomain.comui_url_protocol: http or https(我这边使用https，如果使用http后面证书部分可以忽略)db_password = password（mysql数据库密码）ssl_cert = /root/cert/yourdomain.com.crtssl_cert_key = /root/cert/yourdomain.com.key 启动harbor123# cd /opt/harbor# ./prepare# ./install.sh 12345678910[root@cheng harbor]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES146f85e00e03 vmware/nginx-photon:v1.5.0 &quot;nginx -g &apos;daemon ...&quot; 4 hours ago Up 33 minutes (healthy) 0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp, 0.0.0.0:4443-&gt;4443/tcp nginx80983c6fab8a vmware/harbor-jobservice:v1.5.0 &quot;/harbor/start.sh&quot; 4 hours ago Up 33 minutes harbor-jobservicef1b10ff3b2f3 vmware/harbor-ui:v1.5.0 &quot;/harbor/start.sh&quot; 4 hours ago Up 33 minutes (healthy) harbor-ui0eab9eef6442 vmware/harbor-db:v1.5.0 &quot;/usr/local/bin/do...&quot; 4 hours ago Up 33 minutes (healthy) 3306/tcp harbor-db50ad985dda9b vmware/harbor-adminserver:v1.5.0 &quot;/harbor/start.sh&quot; 4 hours ago Up 33 minutes (healthy) harbor-adminserver827a0883f325 vmware/registry-photon:v2.6.2-v1.5.0 &quot;/entrypoint.sh se...&quot; 4 hours ago Up 33 minutes (healthy) 5000/tcp registrya4c156cfe376 vmware/redis-photon:v1.5.0 &quot;docker-entrypoint...&quot; 4 hours ago Up 33 minutes 6379/tcp redisacb2adc81be9 vmware/harbor-log:v1.5.0 &quot;/bin/sh -c /usr/l...&quot; 4 hours ago Up 33 minutes (healthy) 127.0.0.1:1514-&gt;10514/tcp harbor-log 启动成功！ 验证页面访问： 登录用户名admin，默认密码Harbor12345[图片上传失败…(image-cff177-1539240618559)] docker登录：docker login reg.cheng.com ；然后就可以上传下载镜像了。docker tag SOURCE_IMAGE[:TAG] reg.cheng.com/myproject/IMAGE[:TAG]docker push reg.cheng.com/myproject/IMAGE[:TAG]注： 如果修改配置文件需要重新执行./prepare脚本重新生成配置，再重建容器！ docker-compose up -d 对于其他节点来说，需要先拷贝ca证书到每个计算节点，然后执行cp ca.crt /etc/docker/certs.d/reg.yourdomain.com，这样才能做证书验证。 注：修改docker配置后需要重启harbor123# systemctl restart docker# docker-compose stop# docker-compose start]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes+Docker+SVN+Jenkins+Maven DevOps]]></title>
    <url>%2F2018%2F12%2F14%2FKubernetes-Docker-SVN-Jenkins-Maven-DevOps%2F</url>
    <content type="text"><![CDATA[随着分布式开发和微服务的大量引进，应用测试、发布到上线成为了项目的一大痛点，我们不得不考虑自动化平台的搭建既使用。通过查找相关文档，得到证实DevOps（Development和Operations的组合词）是目前最好的实践方式，对CI/CD的诠释也相对完整。下图直观表现了一体化思维，从项目源码到应用上线部署只需一个按钮搞定，本文是由自己搭建所有组件并成功演示了一键打包部署（项目打包、镜像生成、服务编排）. 流程结构流程说明：1、用户向Gitlab或SVN提交代码，代码中包含Dockerfile文件；2、Jenkins监听代码库的推送和变更事件；3、Jenkins调用Maven插件对源码进行编译打包；4、Jenkins调用docker工具根据Dockerfile文件生成镜像，并推送镜像至Harbor仓库；5、Jenkins通过SSH远程调用Kubernetes集群的Master节点，更新Pod的的模板yaml文件，调用kubectl命令进行发布操作；6、Kubernetes集群的Node节点从Harbor仓库拉取镜像，启动Pod和应用容器。 实施步骤kubernets测试机或高可用集群环境搭建 已完成docker harbor私有仓库搭建 已完成kubernets+harbor+docker+svn+Jenkins+maven代码持续集成与自动部署jdk和maven安装12# tar -zxvf jdk-8u144-linux-x64.tar.gz -C /usr/local# tar -zxvf apache-maven-3.5.4-bin.tar.gz -C /usr/local 配置环境变量：123456789#set java enviromentJAVA_HOME=/usr/local/jdk1.8.0_152JRE_HOME=/usr/local/jdk1.8.0_152/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH#set maven enviromentexport MAVEN_HOME=/usr/local/apache-maven-3.5.4export PATH=$MAVEN_HOME/bin:$PATH 验证：12# java -version# mvn -v SVN使用公司的Jenkins安装12345678# wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo# wget -q -O - http://pkg.jenkins.io/debian-stable/jenkins.io.key# sh -&apos;echo deb http://pkg.jenkins-ci.org/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list&apos;# yum install jenkins# service jenkins restart# systemctl status jenkins.service# systemctl daemon-reload# service jenkins restart 注意报错：Starting Jenkins bash: /usr/bin/java: No such file or directory1# vim /etc/init.d/jenkins` 修改java路径为自己安装的路径：/usr/local/jdk1.8.0_152/bin/javaJenkins默认设置：日志路径：/var/log/jenkins/jenkins.log配置文件：/etc/sysconfig/jenkins默认启用8080端口Jenkins权限变更：由于Jenkins需要执行shell脚本，为后续操作方便给Jenkins一个root权限1、vim /etc/sysconfig/jenkins JENKINS_USER 改为root2、更改相关目录权限123chown –R root:root /var/lib/jenkinschown –R root:root /var/cache/jenkinschown –R root:root /var/log/jenkins 3、重启Jenkinsservice jenkins restart需要/var/lib/jenkins/secrets/initialAdminPassword的密码解锁JenkinsJenkins邮件通知设置参照： 插件安装选择默认建议安装，额外插件： Publish Over SSH、 docker-build-step、 Maven Integration plugin、 SSH Slaves pluginJenkins全局工具设置：系统管理-&gt;全局工具配置 新建maven项目并配置 至此，一键部署应用到kubernetes集群就完成了！]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k8s 命令总结]]></title>
    <url>%2F2018%2F12%2F14%2Fk8s-%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Kubernetes 常用安装和使用命令总结 获取所有命名空间上的podkubectl get pod -o wide --all-namespaces 查看pod IP时使用kubectl get services 查看dsecp-sso-server-w5tx2 日志kubectl describe --namespace=default po dsecp-sso-server-w5tx2 通过yaml文件创建：kubectl create -f xxx.yaml （不建议使用，无法更新，必须先delete）kubectl apply -f xxx.yaml（创建+更新，可以重复使用） 通过yaml文件删除：kubectl delete -f xxx.yaml 查看kube-system namespace下面的pod/svc/deployment 等等（-o wide 选项可以查看存在哪个对应的节点）kubectl get pod/svc/deployment -n kube-system 查看所有namespace下面的pod/svc/deployment等等kubectl get pod/svc/deployment --all-namcpaces 重启pod（无法删除对应的应用，因为存在deployment/rc之类的副本控制器，删除pod也会重新拉起来）kubectl get pod -n kube-system 查看pod描述：kubectl describe pod XXX -n kube-system 查看pod 日志 （如果pod有多个容器需要加-c 容器名）kubectl logs xxx -n kube-system 删除应用（先确定是由说明创建的，再删除对应的kind）：kubectl delete deployment xxx -n kube-system 根据label删除：kubectl delete pod -l app=flannel -n kube-system 扩容kubectl scale deployment spark-worker-deployment --replicas=8 导出配置文件： ## 导出proxy kubectl get ds -n kube-system -l k8s-app=kube-proxy -o yaml&gt;kube-proxy-ds.yaml ## 导出kube-dns 12 kubectl get deployment -n kube-system -l k8s-app=kube-dns -o yaml &gt;kube-dns-dp.yaml kubectl get services -n kube-system -l k8s-app=kube-dns -o yaml &gt;kube-dns-services.yaml ## 导出所有 configmap kubectl get configmap -n kube-system -o wide -o yaml &gt; configmap.yaml 复杂操作命令： ### 删除kube-system 下Evicted状态的所有pod： kubectl get pods -n kube-system |grep Evicted| awk &#39;{print $1}&#39;|xargs kubectl delete pod -n kube-system 以下为维护环境相关命令： 重启kubelet服务 12systemctl daemon-reloadsystemctl restart kubelet 修改启动参数vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf 查看集群信息kubectl cluster-info 查看各组件信息kubectl get componentstatuses 查看kubelet进程启动参数ps -ef | grep kubelet 查看日志:journalctl -u kubelet -f 设为不可调度状态：kubectl cordon node1 将pod赶到其他节点：kubectl drain node1 解除不可调度状态kubectl uncordon node1 master运行podkubectl taint nodes master.k8s node-role.kubernetes.io/master- master不运行podkubectl taint nodes master.k8s node-role.kubernetes.io/master=:NoSchedule]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[k8s 测试 dns]]></title>
    <url>%2F2018%2F12%2F14%2Fk8s-%E6%B5%8B%E8%AF%95-dns%2F</url>
    <content type="text"><![CDATA[前面我们已经搭建好环境，现在需要测试一下dns是否可用1kubectl run curl --image=radial/busyboxplus:curl -i --ttyWaiting for pod default/curl-2421989462-3xx4j to be running, status is Pending, pod ready: falseWaiting for pod default/curl-2421989462-3xx4j to be running, status is Pending, pod ready: falseWaiting for pod default/curl-2421989462-3xx4j to be running, status is Pending, pod ready: falseWaiting for pod default/curl-2421989462-3xx4j to be running, status is Pending, pod ready: false 进入后执行nslookup kubernetes.default确认解析正常。 12345[ root@curl-2421989462-3xx4j:/ ]$ nslookup kubernetes.defaultServer: 10.96.0.10Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.localName: kubernetes.defaultAddress 1: 10.96.0.1 kubernetes.default.svc.cluster.local 测试OK后，删除掉curl这个Pod。1kubectl delete deploy curl` 到这一步就可以向集群中发布微服务了，同时可以使用kubeadm join命令添加新的Node到集群中]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kubernetes 重要概念]]></title>
    <url>%2F2018%2F12%2F14%2Fkubernetes-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[在实践之前，我们必须了解一下kubernets的几个重要概念，它们是组成kubernets集群的基石。 ClusterCluster 是计算、存储和网络资源的集合，Kubernetes 利用这些资源运行各种基于容器的应用。 MasterMaster 是 Cluster 的大脑，它的主要职责是调度，即决定将应用放在哪里运行。Master 运行 Linux 操作系统，可以是物理机或者虚拟机。为了实现高可用，可以运行多个 Master。 NodeNode 的职责是运行容器应用。Node 由 Master 管理，Node 负责监控并汇报容器的状态，并根据 Master 的要求管理容器的生命周期。Node 运行在 Linux 操作系统，可以是物理机或者是虚拟机。 在前面交互式教程中我们创建的 Cluster 只有一个主机 host01，它既是 Master 也是 Node。 PodPod是kubernets的最小工作单元。每个pod包含一个或多个容器。pod中的容器会做为一个整体被master调度到一个node上运行。 kubernets引入pod主要基于下面两个目的： 可管理性 有些容器天生就是需要紧密联系，一起工作。Pod提供了比容器更高层次的抽象，将它们封装到一个部署单元中。Kubernetes以Pod为最小单元进行调度、扩展、资源共享、管理生命周期。 通信和资源共享 Pod中所有容器使用同一个网络namespace，即相同的IP地址和Port空间。它们可以直接使用localhost进行通信。同样的，这些容器可以共享存储，当kubernets挂在volume到pod，本质上是将volume挂在到pod中的每一个容器。 Pod有两种使用方式： 运行单一容器 one-container-per-Pod 是 Kubernetes 最常见的模型，这种情况下，只是将单个容器简单封装成 Pod。即便是只有一个容器，Kubernetes 管理的也是 Pod 而不是直接管理容器。 运行多个容器 但问题在于：哪些容器应该放到一个 Pod 中？ 答案是：这些容器联系必须 非常紧密，而且需要 直接共享资源。 ControllerKubernetes 通常不会直接创建 Pod，而是通过 Controller 来管理 Pod 的。Controller 中定义了 Pod 的部署特性，比如有几个副本，在什么样的 Node 上运行等。为了满足不同的业务场景，Kubernetes 提供了多种 Controller，包括 Deployment、ReplicaSet、DaemonSet、StatefuleSet、Job 等，我们逐一讨论。 Deployment是最常用的 Controller，比如前面在线教程中就是通过创建 Deployment 来部署应用的。Deployment 可以管理 Pod 的多个副本，并确保 Pod 按照期望的状态运行。 ReplicaSet实现了 Pod 的多副本管理。使用 Deployment 时会自动创建 ReplicaSet，也就是说 Deployment 是通过 ReplicaSet 来管理 Pod 的多个副本，我们通常不需要直接使用 ReplicaSet。 DaemonSet用于每个 Node 最多只运行一个 Pod 副本的场景。正如其名称所揭示的，DaemonSet 通常用于运行 daemon。 StatefuleSet能够保证 Pod 的每个副本在整个生命周期中名称是不变的。而其他 Controller 不提供这个功能，当某个 Pod 发生故障需要删除并重新启动时，Pod 的名称会发生变化。同时 StatefuleSet 会保证副本按照固定的顺序启动、更新或者删除。 Job用于运行结束就删除的应用。而其他 Controller 中的 Pod 通常是长期持续运行。 ServiceDeployment 可以部署多个副本，每个 Pod 都有自己的 IP，外界如何访问这些副本呢？ 通过 Pod 的 IP 吗？ 要知道 Pod 很可能会被频繁地销毁和重启，它们的 IP 会发生变化，用 IP 来访问不太现实。 答案是 Service。 Kubernetes Service 定义了外界访问一组特定 Pod 的方式。Service 有自己的 IP 和端口，Service 为 Pod 提供了负载均衡。 Kubernetes 运行容器（Pod）与访问容器（Pod）这两项任务分别由 Controller 和 Service 执行。 Namespace如果有多个用户或项目组使用同一个 Kubernetes Cluster，如何将他们创建的 Controller、Pod 等资源分开呢？ 答案就是 Namespace。 Namespace 可以将一个物理的 Cluster 逻辑上划分成多个虚拟 Cluster，每个 Cluster 就是一个 Namespace。不同 Namespace 里的资源是完全隔离的。 Kubernetes 默认创建了两个 Namespace。 [图片上传失败…(image-be4556-1547737146536)] default – 创建资源时如果不指定，将被放到这个 Namespace 中。 kube-system – Kubernetes 自己创建的系统资源将放到这个 Namespace 中。 熟悉了 k8s 的这些重要概念，下节开始，我们将搭建自己的 Kubernetes 集群。]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 kubeadm 的 kubernetes 高可用集群部署]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%9F%BA%E4%BA%8E-kubeadm-%E7%9A%84-kubernetes-%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[部署概要说明kubernetes高可用的核心架构是master的高可用，kubectl、客户端以及nodes访问load balancer实现高可用。 详细部署架构图： kubernetes组件说明1.kube-apiserver：集群核心，集群API接口、集群各个组件通信的中枢；集群安全控制； 2.etcd：集群的数据中心，用于存放集群的配置以及状态信息，非常重要，如果数据丢失那么集群将无法恢复；因此高可用集群部署首先就是etcd是高可用集群； 3.kube-scheduler：集群Pod的调度中心；默认kubeadm安装情况下–leader-elect参数已经设置为true，保证master集群中只有一个kube-scheduler处于活跃状态； 4.kube-controller-manager：集群状态管理器，当集群状态与期望不同时，kcm会努力让集群恢复期望状态，比如：当一个pod死掉，kcm会努力新建一个pod来恢复对应replicas set期望的状态；默认kubeadm安装情况下–leader-elect参数已经设置为true，保证master集群中只有一个kube-controller-manager处于活跃状态； 5.kubelet: kubernetes node agent，负责与node上的docker engine打交道； 6.kube-proxy: 每个node上一个，负责service vip到endpoint pod的流量转发，当前主要通过设置iptables规则实现。 负载均衡keepalived集群设置一个虚拟ip地址，虚拟ip地址指向k8s-master1、k8s-master2、k8s-master3。nginx用于k8s-master1、k8s-master2、k8s-master3的apiserver的负载均衡。外部kubectl以及nodes访问apiserver的时候就可以用过keepalived的虚拟ip(172.24.12.80)以及nginx端口(8443)访问master集群的apiserver。 部署安装主节点安装清单 主机名 IP地址 说明 安装组件 K8s-master1 172.24.12.32 master节点1 keepalived、nginx、etcd、kubelet、kube-apiserver、kube-scheduler、kube-proxy、kube-dashboard、heapster、docker K8s-master2 172.24.12.33 master节点2 keepalived、nginx、etcd、kubelet、kube-apiserver、kube-scheduler、kube-proxy、kube-dashboard、heapster、docker K8s-master3 172.24.12.34 master节点3 keepalived、nginx、etcd、kubelet、kube-apiserver、kube-scheduler、kube-proxy、kube-dashboard、heapster、docker 无 172.24.12.80 keepalived虚拟IP 无 K8s-node1~ 172.24.12.35~ node节点 kubelet、kube-proxy、docker 安装前准备版本信息 linux版本： 12[root@k8s-master1 yaml]# cat /etc/redhat-release CentOS Linux release 7.5.1804 (Core) docker版本： 12345678910111213141516171819[root@k8s-master1 yaml]# docker version Client: Version: 1.13.1 API version: 1.26 Package version: docker-1.13.1-63.git94f4240.el7.centos.x86_64 Go version: go1.9.4 Git commit: 94f4240/1.13.1 Built: Fri May 18 15:44:33 2018 OS/Arch: linux/amd64 Server: Version: 1.13.1 API version: 1.26 (minimum version 1.12) Package version: docker-1.13.1-63.git94f4240.el7.centos.x86_64 Go version: go1.9.4 Git commit: 94f4240/1.13.1 Built: Fri May 18 15:44:33 2018 OS/Arch: linux/amd64 Experimental: false kubeadm版本： 1v1.10.3 kubeletl版本： 1v1.10.3 docker镜像准备 执行脚本： 123456789#!/bin/bashimages=(kube-proxy-amd64:v1.10.3 kube-scheduler-amd64:v1.10.3 kube-controller-manager-amd64:v1.10.3 kube-apiserver-amd64:v1.10.3etcd-amd64:3.1.12 pause-amd64:3.1 kubernetes-dashboard-amd64:v1.8.3 k8s-dns-sidecar-amd64:1.14.8 k8s-dns-kube-dns-amd64:1.14.8k8s-dns-dnsmasq-nanny-amd64:1.14.8 heapster-amd64:v1.5.2)for imageName in $&#123;images[@]&#125; ; do docker pull keveon/$imageName docker tag keveon/$imageName k8s.gcr.io/$imageName docker rmi keveon/$imageNamedone 额外镜像 123docker pull nginxdocker pull keveon/flannel:v0.9.1-amd64docker tag keveon/flannel:v0.9.1-amd64 quay.io/coreos/flannel:v0.9.1-amd64 系统设置以下在kubernetes所有节点上都是使用root用户进行操作：1.在kubernetes所有节点上增加kubernetes仓库：12345678cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0EOF 2.在kubernetes所有节点上进行系统更新1[root@k8s-master1 yaml]# yum update -y 3.在kubernetes所有节点上关闭防火墙1systemctl disable firewalld &amp;&amp; systemctl stop firewalld &amp;&amp; systemctl status firewalld 4.在kubernetes所有节点上设置SELINUX为permissive模式12$ vi /etc/selinux/configSELINUX=permissive 5.在kubernetes所有节点上设置iptables参数，否则kubeadm init会提示错误123$ vi /etc/sysctl.confnet.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-ip6tables = 1 6.关闭各节点swap1swapoff -a #会关闭所有swap 7.主机名修改1hostnamectl --static set-hostname k8s-master1 8.在kubernetes所有节点上重启主机1reboot 由于篇幅太长，我就用两章来介绍高可用 Kubernetes 的安装过程。下一张是最重要的安装内容！]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 kubeadm 搭建 k8s-1.10.0 开发测试集群环境]]></title>
    <url>%2F2018%2F12%2F14%2F%E4%BD%BF%E7%94%A8-kubeadm-%E6%90%AD%E5%BB%BA-k8s-1-10-0-%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[环境描述采用CentOS7.5，docker 1.13，kubeadm 1.10.0，etcd 3.0， k8s 1.10.0我们这里选用三个节点搭建一个实验环境。172.24.12.32 k8smaster172.24.12.33 k8snode1172.24.12.34 k8snode2 准备环境参照上篇文章配置好各节点hosts文件关闭各节点系统防火墙关闭各节点SElinux关闭各节点swap配置各节点系统内核参数使流过网桥的流量也进入iptables/netfilter框架中，在/etc/sysctl.conf中添加以下配置123net.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-ip6tables = 1sysctl -p 使用kubeadm安装：​ 首先配置各节点阿里K8S YUM源12345678910cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0EOFyum -y install epel-releaseyum clean allyum makecache 在各节点安装kubeadm和相关工具包1yum -y install docker kubernetes-cni-0.6.0-0.x86_64 kubelet-1.10.0-0.x86_64 kubectl-1.10.0-0.x86_64 kubeadm-1.10.0-0.x86_64 启动Docker与kubelet服务12systemctl enable docker &amp;&amp; systemctl start dockersystemctl enable kubelet &amp;&amp; systemctl start kubelet ​提示：此时kubelet的服务运行状态是异常的，因为缺少主配置文件kubelet.conf。但可以暂不处理，因为在完成Master节点的初始化后才会生成这个配置文件。​ 下载K8S相关镜像（Master节点操作）开始下载k8s相关镜像，下载后将镜像名改为k8s.gcr.io/开头的名字，以便kubeadm识别使用。123456789#!/bin/bashimages=(kube-proxy-amd64:v1.10.0 kube-scheduler-amd64:v1.10.0 kube-controller-manager-amd64:v1.10.0 kube-apiserver-amd64:v1.10.0etcd-amd64:3.1.12 pause-amd64:3.1 kubernetes-dashboard-amd64:v1.8.3 k8s-dns-sidecar-amd64:1.14.8 k8s-dns-kube-dns-amd64:1.14.8k8s-dns-dnsmasq-nanny-amd64:1.14.8)for imageName in $&#123;images[@]&#125; ; do docker pull keveon/$imageName docker tag keveon/$imageName k8s.gcr.io/$imageName docker rmi keveon/$imageNamedone ​上面的shell脚本主要做了3件事，下载各种需要用到的容器镜像、重新打标记为符合k8s命令规范的版本名称、清除旧的容器镜像。提示：镜像版本一定要和kubeadm安装的版本一致，否则会出现time out问题。​ 初始化安装K8S Master执行上述shell脚本，等待下载完成后，执行kubeadm init12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[root@k8smaster ~]# kubeadm init --kubernetes-version=v1.10.0 --pod-network-cidr=10.244.0.0/16[init] Using Kubernetes version: v1.10.0[init] Using Authorization modes: [Node RBAC][preflight] Running pre-flight checks. [WARNING Service-Kubelet]: kubelet service is not enabled, please run &apos;systemctl enable kubelet.service&apos; [WARNING FileExisting-crictl]: crictl not found in system pathSuggestion: go get github.com/kubernetes-incubator/cri-tools/cmd/crictl[preflight] Starting the kubelet service[certificates] Generated ca certificate and key.[certificates] Generated apiserver certificate and key.[certificates] apiserver serving cert is signed for DNS names [k8smaster kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.0.100.202][certificates] Generated apiserver-kubelet-client certificate and key.[certificates] Generated etcd/ca certificate and key.[certificates] Generated etcd/server certificate and key.[certificates] etcd/server serving cert is signed for DNS names [localhost] and IPs [127.0.0.1][certificates] Generated etcd/peer certificate and key.[certificates] etcd/peer serving cert is signed for DNS names [k8smaster] and IPs [10.0.100.202][certificates] Generated etcd/healthcheck-client certificate and key.[certificates] Generated apiserver-etcd-client certificate and key.[certificates] Generated sa key and public key.[certificates] Generated front-proxy-ca certificate and key.[certificates] Generated front-proxy-client certificate and key.[certificates] Valid certificates and keys now exist in &quot;/etc/kubernetes/pki&quot;[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/admin.conf&quot;[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/kubelet.conf&quot;[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/controller-manager.conf&quot;[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/scheduler.conf&quot;[controlplane] Wrote Static Pod manifest for component kube-apiserver to &quot;/etc/kubernetes/manifests/kube-apiserver.yaml&quot;[controlplane] Wrote Static Pod manifest for component kube-controller-manager to &quot;/etc/kubernetes/manifests/kube-controller-manager.yaml&quot;[controlplane] Wrote Static Pod manifest for component kube-scheduler to &quot;/etc/kubernetes/manifests/kube-scheduler.yaml&quot;[etcd] Wrote Static Pod manifest for a local etcd instance to &quot;/etc/kubernetes/manifests/etcd.yaml&quot;[init] Waiting for the kubelet to boot up the control plane as Static Pods from directory &quot;/etc/kubernetes/manifests&quot;.[init] This might take a minute or longer if the control plane images have to be pulled.[apiclient] All control plane components are healthy after 21.001790 seconds[uploadconfig] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace[markmaster] Will mark node k8smaster as master by adding a label and a taint[markmaster] Master k8smaster tainted and labelled with key/value: node-role.kubernetes.io/master=&quot;&quot;[bootstraptoken] Using token: thczis.64adx0imeuhu23xv[bootstraptoken] Configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials[bootstraptoken] Configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token[bootstraptoken] Configured RBAC rules to allow certificate rotation for all node client certificates in the cluster[bootstraptoken] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace[addons] Applied essential addon: kube-dns[addons] Applied essential addon: kube-proxyYour Kubernetes master has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/You can now join any number of machines by running the following on each nodeas root: kubeadm join 10.0.100.202:6443 --token thczis.64adx0imeuhu23xv --discovery-token-ca-cert-hash sha256:fa7b11bb569493fd44554aab0afe55a4c051cccc492dbdfafae6efeb6ffa80e6 ​​提示：选项–kubernetes-version=v1.10.0是必须的，否则会因为访问google网站被墙而无法执行命令。这里使用v1.10.0版本，刚才前面也说到了下载的容器镜像版本必须与K8S版本一致否则会出现time out。上面的命令大约需要1分钟的过程，期间可以观察下tail -f /var/log/message日志文件的输出，掌握该配置过程和进度。上面最后一段的输出信息保存一份，后续添加工作节点还要用到。​ 配置kubectl认证信息（Master节点操作） 对于非root用户 123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 对于root用户 1export KUBECONFIG=/etc/kubernetes/admin.conf ​ 安装flannel网络（Master节点操作）12345678910111213141516171819mkdir -p /etc/cni/net.d/cat &lt;&lt;EOF&gt; /etc/cni/net.d/10-flannel.conf&#123;“name”: “cbr0”,“type”: “flannel”,“delegate”: &#123;“isDefaultGateway”: true&#125;&#125;EOFmkdir /usr/share/oci-umount/oci-umount.d -pmkdir /run/flannel/cat &lt;&lt;EOF&gt; /run/flannel/subnet.envFLANNEL_NETWORK=10.244.0.0/16FLANNEL_SUBNET=10.244.1.0/24FLANNEL_MTU=1450FLANNEL_IPMASQ=trueEOFkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml ​ 让node1、node2加入集群在node1和node2节点上分别执行kubeadm join命令，加入集群：123456789101112131415[root@k8snode1 ~]# kubeadm join 10.0.100.202:6443 --token thczis.64adx0imeuhu23xv --discovery-token-ca-cert-hash sha256:fa7b11bb569493fd44554aab0afe55a4c051cccc492dbdfafae6efeb6ffa80e6[preflight] Running pre-flight checks. [WARNING Service-Kubelet]: kubelet service is not enabled, please run &apos;systemctl enable kubelet.service&apos; [WARNING FileExisting-crictl]: crictl not found in system pathSuggestion: go get github.com/kubernetes-incubator/cri-tools/cmd/crictl[discovery] Trying to connect to API Server &quot;10.0.100.202:6443&quot;[discovery] Created cluster-info discovery client, requesting info from &quot;https://10.0.100.202:6443&quot;[discovery] Requesting info from &quot;https://10.0.100.202:6443&quot; again to validate TLS against the pinned public key[discovery] Cluster info signature and contents are valid and TLS certificate validates against pinned roots, will use API Server &quot;10.0.100.202:6443&quot;[discovery] Successfully established connection with API Server &quot;10.0.100.202:6443&quot;This node has joined the cluster:* Certificate signing request was sent to master and a response was received.* The Kubelet was informed of the new secure connection details.Run &apos;kubectl get nodes&apos; on the master to see this node join the cluster. 提示：这段命令其实就是前面K8S Matser安装成功后我让你们保存的那段命令。默认情况下，Master节点不参与工作负载，但如果希望安装出一个All-In-One的k8s环境，则可以执行以下命令，让Master节点也成为一个Node节点：1kubectl taint nodes --all node-role.kubernetes.io/master-` ​​ 验证K8S Master是否搭建成功（Master节点操作）​ 查看节点状态1kubectl get nodes ​ 查看pods状态1kubectl get pods --all-namespaces ​ 查看K8S集群状态1kubectl get cs ​ 当安装失败了，怎么清理环境重新安装啊？下面教大家一条命令：​1kubeadm reset ​好了，至此就完成了K8S三节点集群的安装部署。]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 kubeadm 的 kubernetes 高可用集群部署]]></title>
    <url>%2F2018%2F12%2F14%2F%E5%9F%BA%E4%BA%8E-kubeadm-%E7%9A%84-kubernetes-%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[上一篇我们的基本工作已经准备完成，这篇我们说重要的安装过程。 kubernetes 相关服务安装 在 kubernetes 所有节点上验证 SELINUX 模式，必须保证 SELINUX 为 permissive 模式，否则 kubernetes 启动会出现各种异常。 1[root@k8s-master1 yaml]# getenforcePermissive 在 kubernetes 所有节点上安装并启动 kubernetes 和 docker 1yum install -y kubernetes-cni-0.6.0-0.x86_64 kubelet-1.10.3-0.x86_64 kubectl-1.10.3-0.x86_64 kubeadm-1.10.3-0.x86_64systemctl enable docker &amp;&amp; systemctl start dockersystemctl enable kubelet &amp;&amp; systemctl start kubelet 独立 etcd 集群部署 在 k8s-master1 节点上以 docker 方式启动 etcd 集群 1$ docker stop etcd &amp;&amp; docker rm etcd$ rm -rf /var/lib/etcd-cluster$ mkdir -p /var/lib/etcd-cluster$ docker run -d \--restart always \-v /etc/ssl/certs:/etc/ssl/certs \-v /var/lib/etcd-cluster:/var/lib/etcd \-p 4001:4001 \-p 2380:2380 \-p 2379:2379 \--name etcd \k8s.gcr.io/etcd-amd64:3.2.17 \etcd --name=etcd0 \--advertise-client-urls=http://172.24.12.32:2379,http://172.24.12.32:4001 \--listen-client-urls=http://0.0.0.0:2379,http://0.0.0.0:4001 \--initial-advertise-peer-urls=http://172.24.12.32:2380 \--listen-peer-urls=http://0.0.0.0:2380 \--initial-cluster-token=9477af68bbee1b9ae037d6fd9e7efefd \--initial-cluster=etcd0=http://172.24.12.32:2380,etcd1=http://172.24.12.33:2380,etcd2=http://172.24.12.34:2380 \--initial-cluster-state=new \--auto-tls \--peer-auto-tls \--data-dir=/var/lib/etcd 在 k8s-master2 节点上以 docker 方式启动 etcd 集群 1$ docker stop etcd &amp;&amp; docker rm etcd$ rm -rf /var/lib/etcd-cluster$ mkdir -p /var/lib/etcd-cluster$ docker run -d \--restart always \-v /etc/ssl/certs:/etc/ssl/certs \-v /var/lib/etcd-cluster:/var/lib/etcd \-p 4001:4001 \-p 2380:2380 \-p 2379:2379 \--name etcd \k8s.gcr.io/etcd-amd64:3.2.17 \etcd --name=etcd1 \--advertise-client-urls=http://172.24.12.33:2379,http://172.24.12.33:4001 \--listen-client-urls=http://0.0.0.0:2379,http://0.0.0.0:4001 \--initial-advertise-peer-urls=http://172.24.12.33:2380 \--listen-peer-urls=http://0.0.0.0:2380 \--initial-cluster-token=9477af68bbee1b9ae037d6fd9e7efefd \--initial-cluster=etcd0=http://172.24.12.32:2380,etcd1=http://172.24.12.33:2380,etcd2=http://172.24.12.34:2380 \--initial-cluster-state=new \--auto-tls \--peer-auto-tls \--data-dir=/var/lib/etcd 在 k8s-master3 节点上以 docker 方式启动 etcd 集群 1$ docker stop etcd &amp;&amp; docker rm etcd$ rm -rf /var/lib/etcd-cluster$ mkdir -p /var/lib/etcd-cluster$ docker run -d \--restart always \-v /etc/ssl/certs:/etc/ssl/certs \-v /var/lib/etcd-cluster:/var/lib/etcd \-p 4001:4001 \-p 2380:2380 \-p 2379:2379 \--name etcd \k8s.gcr.io/etcd-amd64:3.2.17 \etcd --name=etcd2 \--advertise-client-urls=http://172.24.12.34:2379,http://172.24.12.34:4001 \--listen-client-urls=http://0.0.0.0:2379,http://0.0.0.0:4001 \--initial-advertise-peer-urls=http://172.24.12.34:2380 \--listen-peer-urls=http://0.0.0.0:2380 \--initial-cluster-token=9477af68bbee1b9ae037d6fd9e7efefd \--initial-cluster=etcd0=http://172.24.12.32:2380,etcd1=http://172.24.12.33:2380,etcd2=http://172.24.12.34:2380 \--initial-cluster-state=new \--auto-tls \--peer-auto-tls \--data-dir=/var/lib/etcd 在 k8s-master1、k8s-master2、k8s-master3 上检查 etcd 启动状态 1[root@k8s-master1 yaml]# docker exec -ti etcd ash/ # etcdctl member list7952c466eeed1e71: name=etcd0 peerURLs=http://172.24.12.32:2380 clientURLs=http://172.24.12.32:2379,http://172.24.12.32:4001 isLeader=falseea0f9c89ab07d1c2: name=etcd2 peerURLs=http://172.24.12.34:2380 clientURLs=http://172.24.12.34:2379,http://172.24.12.34:4001 isLeader=truefd15cb75a309af35: name=etcd1 peerURLs=http://172.24.12.33:2380 clientURLs=http://172.24.12.33:2379,http://172.24.12.33:4001 isLeader=false/ # etcdctl cluster-healthmember 7952c466eeed1e71 is healthy: got healthy result from http://172.24.12.32:2379member ea0f9c89ab07d1c2 is healthy: got healthy result from http://172.24.12.34:2379member fd15cb75a309af35 is healthy: got healthy result from http://172.24.12.33:2379cluster is healthy/ # exit kubeadm 初始化 在 k8s-master1 上修改 kubeadm-init.yaml 文件，设置 etcd.endpoints 的${HOST_IP}为 k8s-master1、k8s-master2、k8s-master3 的 IP 地址 1[root@k8s-master1 yaml]# cat kubeadm-init.yamlapiVersion: kubeadm.k8s.io/v1alpha1kind: MasterConfigurationkubernetesVersion: v1.10.3networking: podSubnet: 10.244.0.0/16apiServerCertSANs:- k8s-master1- k8s-master2- k8s-master3- 172.24.12.32- 172.24.12.33- 172.24.12.34- 172.24.12.80etcd: endpoints: - http://172.24.12.32:2379 - http://172.24.12.33:2379 - http://172.24.12.34:2379 注：如果使用kubeadm初始化集群，启动过程可能会卡在以下位置，那么可能是因为 cgroup-driver 参数与 docker 的不一致引起，如下： 1[apiclient] Created API client, waiting for the control plane to become ready$ journalctl -t kubelet -S &apos;2017-06-08&apos; #查看日志，发现如下错误error: failed to run Kubelet: failed to create kubelet: misconfiguration: kubelet cgroup driver: &quot;systemd&quot; 需要修改 KUBELET_CGROUP_ARGS=–cgroup-driver=systemd 为 KUBELET_CGROUP_ARGS=–cgroup-driver=cgroupfs 1$ vi /etc/systemd/system/kubelet.service.d/10-kubeadm.conf#Environment=&quot;KUBELET_CGROUP_ARGS=--cgroup-driver=systemd&quot; Environment=&quot;KUBELET_CGROUP_ARGS=--cgroup-driver=cgroupfs&quot; 在 k8s-master1 上使用 kubeadm 初始化 kubernetes 集群，连接外部 etcd 集群 1$ kubeadm init --config=/home/yaml/kubeadm-init.yaml 在 k8s-master1 上设置 kubectl 的环境变量 KUBECONFIG，连接 kubelet 1$ vi ~/.bashrc export KUBECONFIG=/etc/kubernetes/admin.conf$ source ~/.bashrc flannel 网络组件安装 1$ kubectl create -f /home/yaml/kube-flannel.yml 在 k8s-master1 上验证 kube-dns 成功启动，大概等待3分钟，验证所有 pods 的状态为 Running，验证方式见 k8s-测试dns 1$ kubectl get pods --all-namespaces -o wide dashboard 和 heapster 组件安装 1kubectl create -f /home/yaml/kubernetes-dashboard-admin.rbac.yamlkubectl create -f /home/yaml/kubernetes-dashboard.yaml 注：在 k8s-master1 上允许在 master 上部署 pod，否则 heapster 会无法部署，执行以下命令： 1$ kubectl taint nodes --all node-role.kubernetes.io/master-node &quot;k8s-master1&quot; taintedkubectl create -f /home/yaml/heapster-rbac.yamlkubectl create -f /home/yaml/heapster.yaml 在本机上访问 dashboard 地址 http://172.24.12.32:30090，验证 heapster 成功启动，查看 Pods 的 CPU 以及 Memory 信息是否正常呈现，如下： dashboard 至此，第一台 master 成功安装，并已经完成 flannel、dashboard、heapster 的部署。 master 集群高可用设置 在 k8s-master1 上把 /etc/kubernetes/ 复制到 k8s-master2、k8s-master3 在 k8s-master2、k8s-master3 上重启 kubelet 服务，并检查 kubelet 服务状态为 active (running) 1systemctl daemon-reload &amp;&amp; systemctl restart kubelet 在 k8s-master2、k8s-master3 上设置 kubectl 的环境变量 KUBECONFIG，连接 kubelet 1$ vi ~/.bashrcexport KUBECONFIG=/etc/kubernetes/admin.conf$ source ~/.bashrc 在 k8s-master2、k8s-master3 检测节点状态，发现节点已经加进来 1[root@k8s-master1 yaml]# kubectl get nodes -o wide nodes 在 k8s-master2、k8s-master3 上修改 kube-apiserver.yaml 的配置，${HOST_IP}改为本机 IP 1$ vi /etc/kubernetes/manifests/kube-apiserver.yaml- --advertise-address=$&#123;HOST_IP&#125; 在 k8s-master2 和 k8s-master3 上的修改 kubelet.conf 设置，${HOST_IP}改为本机 IP 1$ vi /etc/kubernetes/kubelet.confserver: https://$&#123;HOST_IP&#125;:6443 在 k8s-master2 和 k8s-master3 上的重启服务 1$ systemctl daemon-reload &amp;&amp; systemctl restart docker kubelet 创建证书(1)在 k8s-master2 和 k8s-master3 上修改 kubelet.conf 后，由于 kubelet.conf 配置的 crt 和 key 与本机 IP 地址不一致的情况，kubelet 服务会异常退出，crt 和 key 必须重新制作。查看 apiserver.crt 的签名信息，发现 IP Address 以及 DNS 绑定了 k8s-master1，必须进行相应修改。 1$ openssl x509 -noout -text -in /etc/kubernetes/pki/apiserver.crt k8s-apiserver.crt (2)在 k8s-master1、k8s-master2、k8s-master3 上使用 ca.key 和 ca.crt 制作 apiserver.crt 和apiserver.key 1$ mkdir -p /etc/kubernetes/pki-local$ cd /etc/kubernetes/pki-local (3)在 k8s-master1、k8s-master2、k8s-master3 上生成 2048 位的密钥对 1$ openssl genrsa -out apiserver.key 2048 (4)在 k8s-master1、k8s-master2、k8s-master3 上生成证书签署请求文件 1$ openssl req -new -key apiserver.key -subj &quot;/CN=kube-apiserver,&quot; -out apiserver.csr (5)在 k8s-master1、k8s-master2、k8s-master3 上编辑 apiserver.ext 文件，${HOST_NAME}修改为本机主机名，${HOST_IP}修改为本机 IP 地址，${VIRTUAL_IP}修改为 keepalived 的虚拟 IP（172.24.12.80） 1$ vi apiserver.extsubjectAltName = DNS:$&#123;HOST_NAME&#125;,DNS:kubernetes,DNS:kubernetes.default,DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, IP:10.96.0.1, IP:$&#123;HOST_IP&#125;, IP:$&#123;VIRTUAL_IP&#125; (6)在 k8s-master1、k8s-master2、k8s-master3 上使用 ca.key 和 ca.crt 签署上述请求 1$ openssl x509 -req -in apiserver.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out apiserver.crt -days 365 -extfile /etc/kubernetes/pki-local/apiserver.ext (7)在 k8s-master1、k8s-master2、k8s-master3 上查看新生成的证书： 1$ openssl x509 -noout -text -in apiserver.crt k8s-apiserver.crt2 (8)在 k8s-master1、k8s-master2、k8s-master3 上把 apiserver.crt 和 apiserver.key 文件复制到 /etc/kubernetes/pki 目录 1cp apiserver.crt apiserver.key /etc/kubernetes/pki/ 在 k8s-master2 和 k8s-master3 上修改 admin.conf，${HOST_IP}修改为本机 IP 地址 1$ vi /etc/kubernetes/admin.confserver: https://$&#123;HOST_IP&#125;:6443 在 k8s-master2 和 k8s-master3 上修改 controller-manager.conf，${HOST_IP}修改为本机 IP 地址 1$ vi /etc/kubernetes/controller-manager.confserver: https://$&#123;HOST_IP&#125;:6443 在 k8s-master2 和 k8s-master3 上修改 scheduler.conf，${HOST_IP}修改为本机 IP 地址 1$ vi /etc/kubernetes/scheduler.confserver: https://$&#123;HOST_IP&#125;:6443 在 k8s-master1、k8s-master2、k8s-master3 上重启所有服务 1$ systemctl daemon-reload &amp;&amp; systemctl restart docker kubelet 验证高可用安装 在 k8s-master1、k8s-master2、k8s-master3 任意节点上检测服务启动情况，发现 apiserver、controller-manager、kube-scheduler、proxy、flannel 已经在 k8s-master1、k8s-master2、k8s-master3 成功启动 1$ kubectl get pod --all-namespaces -o wide | grep k8s-master1$ kubectl get pod --all-namespaces -o wide | grep k8s-master2$ kubectl get pod --all-namespaces -o wide | grep k8s-master3 服务启动情况 在 k8s-master1、k8s-master2、k8s-master3 任意节点上通过 kubectl logs 检查各个 controller-manager 和 scheduler 的 leader election 结果，可以发现只有一个节点有效表示选举正常 1$ kubectl logs -n kube-system kube-controller-manager-k8s-master1$ kubectl logs -n kube-system kube-controller-manager-k8s-master2$ kubectl logs -n kube-system kube-controller-manager-k8s-master3$ kubectl logs -n kube-system kube-scheduler-k8s-master1$ kubectl logs -n kube-system kube-scheduler-k8s-master2$ kubectl logs -n kube-system kube-scheduler-k8s-master3 在 k8s-master1、k8s-master2、k8s-master3 任意节点上查看 deployment 的情况 1$ kubectl get deploy --all-namespaces deployment的情况 在 k8s-master1、k8s-master2、k8s-master3 任意节点上把 kubernetes-dashboard、kube-dns、 scale up 扩成 replicas=3，保证各个 master 节点上都有运行 1$ kubectl scale --replicas=3 -n kube-system deployment/kube-dns$ kubectl get pods --all-namespaces -o wide| grep kube-dns$ kubectl scale --replicas=3 -n kube-system deployment/kubernetes-dashboard$ kubectl get pods --all-namespaces -o wide| grep kubernetes-dashboard$ kubectl scale --replicas=3 -n kube-system deployment/heapster$ kubectl get pods --all-namespaces -o wide| grep heapster keepalived 安装配置 在 k8s-master、k8s-master2、k8s-master3 上安装 keepalived 1$ yum install -y keepalived$ systemctl enable keepalived &amp;&amp; systemctl restart keepalived 在 k8s-master1、k8s-master2、k8s-master3 上备份 keepalived 配置文件 1$ mv /etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf.bak 在 k8s-master1、k8s-master2、k8s-master3 上设置 apiserver 监控脚本，当 apiserver 检测失败的时候关闭 keepalived 服务，转移虚拟 IP 地址 1$ vi /etc/keepalived/check_apiserver.sh#!/bin/bash err=0 for k in $( seq 1 10 ) do check_code=$(ps -ef|grep kube-apiserver | wc -l) if [ &quot;$check_code&quot; = &quot;1&quot; ]; then err=$(expr $err + 1) sleep 5 continue else err=0 break fi done if [ &quot;$err&quot; != &quot;0&quot; ]; then echo &quot;systemctl stop keepalived&quot; /usr/bin/systemctl stop keepalived exit 1 else exit 0 fi$ chmod a+x /etc/keepalived/check_apiserver.sh 在 k8s-master1、k8s-master2、k8s-master3 上查看接口名字 1$ ip a | grep 172.24.12 在 k8s-master1、k8s-master2、k8s-master3 上设置 keepalived，参数说明如下：state ${STATE}：为 MASTER 或者 BACKUP，只能有一个 MASTERinterface ${INTERFACE_NAME}：为本机的需要绑定的接口名字（通过上边的 ip a 命令查看）mcast_src_ip ${HOST_IP}：为本机的IP地址priority ${PRIORITY}：为优先级，例如 102、101、100，优先级越高越容易选择为 MASTER，优先级不能一样， master设置应高于 backup${VIRTUAL_IP}：为虚拟的 IP 地址，这里设置为 172.24.12.80 1$ vi /etc/keepalived/keepalived.conf keepalived参数设置 在 k8s-master1、k8s-master2、k8s-master3 上重启 keepalived 服务，检测虚拟 IP 地址是否生效 1$ systemctl restart keepalived$ ping 172.24.12.80 nginx负载均衡配置 在 k8s-master1、k8s-master2、k8s-master3 上修改 nginx-default.conf设置，${HOST_IP}对应 k8s-master1、k8s-master2、k8s-master3 的地址。通过 nginx 把访问 apiserver 的 6443 端口负载均衡到 8433 端口上 1$ vi /home/yaml/nginx-default.confstream &#123; upstream apiserver &#123; server $&#123;HOST_IP&#125;:6443 weight=5 max_fails=3 fail_timeout=30s; server $&#123;HOST_IP&#125;:6443 weight=5 max_fails=3 fail_timeout=30s; server $&#123;HOST_IP&#125;:6443 weight=5 max_fails=3 fail_timeout=30s; &#125; server &#123; listen 8443; proxy_connect_timeout 1s; proxy_timeout 3s; proxy_pass apiserver; &#125; &#125; 在 k8s-master1、k8s-master2、k8s-master3 上启动 nginx 容器 1$ docker run -d -p 8443:8443 \ --name nginx-lb \ --restart always \ -v /home/yaml/nginx-default.conf:/etc/nginx/nginx.conf \ nginx 在 k8s-master1、k8s-master2、k8s-master3 上检测 keepalived 服务的虚拟 IP 地址指向 1$ curl -L 192.168.60.80:8443 | wc -l% Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 14 0 14 0 0 18324 0 --:--:-- --:--:-- --:--:-- 14000 1 业务恢复后务必重启 keepalived，否则 keepalived 会处于关闭状态 1$ systemctl restart keepalived 在 k8s-master1、k8s-master2、k8s-master3 上查看 keeplived 日志，有以下输出表示当前虚拟 IP 地址绑定的主机 1$ systemctl status keepalived -lVRRP_Instance(VI_1) Sending gratuitous ARPs on ens160 for 172.24.12.80 kube-proxy配置 在 k8s-master1 上设置 kube-proxy 使用 keepalived 的虚拟IP地址，避免 k8s-master1 异常的时候所有节点的 kube-proxy 连接不上 1$ kubectl get -n kube-system configmap NAME DATA AGE extension-apiserver-authentication 6 4h kube-flannel-cfg 2 4h kube-proxy 1 4h 在 k8s-master1 上修改 configmap/kube-proxy 的 server 指向 keepalived 的虚拟IP地址 1$ kubectl edit -n kube-system configmap/kube-proxy server: https://172.24.12.80:8443 在 k8s-master1 上查看 configmap/kube-proxy 设置情况 1$ kubectl get -n kube-system configmap/kube-proxy -o yaml 在 k8s-master1 上删除所有 kube-proxy 的 pod，让 proxy 重建 1kubectl get pods --all-namespaces -o wide | grep proxy 在 k8s-master1、k8s-master2、k8s-master3 上重启 docker kubelet keepalived 服务 1systemctl restart docker kubelet keepalived 验证 master 集群高可用在 k8s-master1 上检查各个节点 pod 的启动状态，每个上都成功启动 heapster、kube-apiserver、kube-controller-manager、kube-dns、kube-flannel、kube-proxy、kube-scheduler、kubernetes-dashboard、monitoring-grafana、monitoring-influxdb。并且所有 pod 都处于 Running 状态表示正常 1$ kubectl get pods --all-namespaces -o wide | grep k8s-master1$ kubectl get pods --all-namespaces -o wide | grep k8s-master2$ kubectl get pods --all-namespaces -o wide | grep k8s-master3 node 节点加入高可用集群设置 在 k8s-master1 上查看集群的 token 1$ kubeadm token list kubeadm token 在 k8s-node1~k8s-node8 上，${TOKEN}为 k8s-master1 上显示的 token，${VIRTUAL_IP}为 keepalived 的虚拟 IP 地址 172.24.12.80 1$ kubeadm join --token $&#123;TOKEN&#125; $&#123;VIRTUAL_IP&#125;:8443 查看 kubelet status,确保 activing 1[root@k8s-node1 ~]# systemctl start kubelet[root@k8s-node1 ~]# journalctl -xeu kubelet 注：如果有不必要的报错，使用下面 join 方法： 1[root@k8s-node1 ~]# kubeadm join --token efeayj.qa8q6c0ojo72crsn 172.24.12.80:8443 --ignore-preflight-errors &apos;all&apos; --discovery-token-unsafe-skip-ca-verification 部署应用验证集群 在 k8s-node1 ~ k8s-node8 上查看 kubelet 状态，kubelet 状态为 active (running) 表示 kubelet 服务正常启动 1systemctl status keepalived 在 k8s-master1 上检查各个节点状态，发现所有 k8s-nodes 节点成功加入 1[root@k8s-master1 yaml]# kubectl get nodes -o wide kubectl get nodes 在 k8s-master1 上测试部署 nginx 服务，nginx 服务成功部署到 k8s-node1 上 1[root@k8s-master1 yaml]# kubectl run nginx --image=nginx --port=80[root@k8s-master1 yaml]# kubectl get pod -o wide -l=run=nginx run nginx 在 k8s-master1 让 nginx 服务外部可见 1[root@k8s-master1 yaml]# kubectl expose deployment nginx --port=80 --target-port=80 --type=NodePort[root@k8s-master1 yaml]# kubectl get svc -l=run=nginx nginx服务外部可见 访问测试 1[root@k8s-master1 yaml]# curl 172.24.12.35:31012 或者使用浏览器访问，如下： curl nginx 浏览器访问nginx 至此，kubernetes 高可用集群成功部署！]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx https 配置]]></title>
    <url>%2F2018%2F09%2F23%2FNginx-https-%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[准备环境阿里云 腾讯云部署好站点，且使用DNS解析到云服务器的IP地址 接下来就是配置HTTPS的关键步骤 申请证书并下载对应Nginx版本到本地 下载安装Nginx 修改Nginx配置文件 启动Nginx 申请证书证书申请有免费或收费的，我们当然要是有免费的。可到阿里云或者腾讯云的证书管理中申请，注意申请亚洲诚信SSL证书时需要绑定域名，申请完后下载证书zip包。 下载安装Nginx到Nginx官网下载最新版本15以上，并上传到服务器/home目录下安装前先安装其依赖1234yum -y install gcc-c++yum -y install pcre pcre-develyum -y install zlib zlib-develyum -y install openssl openssl-devel 解压Nginx安装包tar.gz到/home目录下，并解析安装123456cd /hometar -zxvf nginx-1.15.4.tar.gzcd nginx-1.15.4.tar.gz./configure --with-http_ssl_modulemakemake install 到此Nginx安装完成，你可以使用以下命令尝试启动，并查看是否成功启动12/usr/local/nginx/sbin/nginxps -ef|grep nginx 修改Nginx配置文件1vim /usr/local/nginx/conf/nginx.conf 12345678910111213141516171819202122server &#123; listen 80; #监听端口 server_name www.corkercode.com; return 301 https://$server_name$request_uri; #强制把http请求转到https &#125;server &#123; listen 443 ssl; server_name www.corkercode.com; ssl_certificate /usr/local/nginx/conf/ssl/1_www.corkercode.com_bundle.crt; #申请的证书上传到服务器的地址 ssl_certificate_key /usr/local/nginx/conf/ssl/2_www.corkercode.com.key; #申请的证书上传到服务器的地址 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://132.232.103.84:8090; #反向代理请求转发到服务器个人网站地址 &#125; &#125; 重启Nginx123ps -ef|grep nginxkill -9 进程号/usr/local/nginx/sbin/nginx 测试访问你的域名，会自动转发到https请求！最后删除冗余文件：12rm -rf /home/nginx-1.15.4.tar.gzrm -rf /home/nginx-1.15.4]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text使用]]></title>
    <url>%2F2018%2F09%2F23%2FSublime-Text%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[参考1 参考2 1.安装Sublime英文版3Sublime官网 Sublime Text 3 最新可用注册码（免破解） 以下两枚注册码用最新的Sublime Text 3 3162的版本亲测可用。 —– BEGIN LICENSE SJOLZY.CN —– Anthony Sansone Single User License EA7E-878563 28B9A648 42B99D8A F2E3E9E0 16DE076E E218B3DC F3606379 C33C1526 E8B58964 B2CB3F63 BDF901BE D31424D2 082891B5 F7058694 55FA46D8 EFC11878 0868F093 B17CAFE7 63A78881 86B78E38 0F146238 BAE22DBB D4EC71A1 0EC2E701 C7F9C648 5CF29CA3 1CB14285 19A46991 E9A98676 14FD4777 2D8A0AB6 A444EE0D CA009B54 —— END LICENSE —— —– BEGIN LICENSE SJOLZY.CN —– Alexey Plutalov Single User License EA7E-860776 3DC19CC1 134CDF23 504DC871 2DE5CE55 585DC8A6 253BB0D9 637C87A2 D8D0BA85 AAE574AD BA7D6DA9 2B9773F2 324C5DEF 17830A4E FBCF9D1D 182406E9 F883EA87 E585BBA1 2538C270 E2E857C2 194283CA 7234FF9E D0392F93 1D16E021 F1914917 63909E12 203C0169 3F08FFC8 86D06EA8 73DDAEF0 AC559F30 A6A67947 B60104C6 —— END LICENSE —— 2.安装Package Control插件——插件管理器方式一 在线安装使用快捷键 Ctrl + ` 调出命令，输入下面代码 import urllib.request,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 方式二 离线手动安装Click the Preferences &gt; Browse Packages… menu Browse up a folder and then into the Installed Packages/ folder Download Package Control.sublime-package and copy it into the Installed Packages/ directory Restart Sublime Text 3.插件安装方式 通过菜单Preferneces -&gt; Package Control打开 选择 Install Package 然后输入插件名 1、 ConvertToUTF8 GBK/GB2312中文编码支持 2、Markdown Editing Markdown编辑插件 3、 MarkdownLivePreview Markdown实时预览插件 4、Bracket Highlighter 用于匹配括号，引号和html标签。对于很长的代码很有用。安装好之后，不需要设置插件会自动生效 5、DocBlockr DocBlockr可以自动生成PHPDoc风格的注释。它支持的语言有Javascript, PHP, ActionScript, CoffeeScript, Java, Objective C, C, C++ 6、Emmet(Zen Coding) 快速生成HTML代码段的插件，强大到无与伦比，不知道的请自行google 7、Themr 主题管理，切换主题的时候，不用自己修改配置文件了，用这个可以方便的切换主题 4.通用快捷键1、Ctrl+Shift+P 打开Package Control，上面已经介绍过了。这里还有个技巧，此技巧在下面的各种地方都能用的上，就是ST支持模糊匹配。比如，你想找Install Package，你在 Package Control 的输入框中install，可以自动匹配到Install Package，也可以简单的输入ip，也能匹配到它，这种模糊匹配的功能很方便。 使用Ctrl+鼠标滚轮可以调整字体大小 2、Ctrl+P 根据文件名打开文件。比如你想打开login/func/funtion.php，你只要在输入框中输入login/func/funtion.php即可，也可以用模糊匹配，如login/function等，模糊匹配还是自己去体验吧。 3、SublimeLinter = 错误语法 4、JsMinifier =自动压缩js文件 5、Sublime CodeIntel =代码自动提示 6、Bracket Highlighter =代码匹配 7、CSScomb CSS =属性排序 8、SublimeTmpl =快速生成文件模板 9、SideBarEnhancements =设置sublime text2/3支持浏览器预览 10、ColorPicker =调色盘 11、Tag = Html格式化 12、Clipboard History = 剪贴板历史记录 13、SideBarEnhancements = 侧栏右键功能增强 14、GBK to UTF8 =GBK转黄成UTF8 15、SFTP =ftp插件 16、WordPress = WordPress函数 17、PHPTidy =排版PHP代码 18、YUI Compressor =压缩JS和CSS文件 19、Alignment =代码对齐 20、Emmet =大名鼎鼎呀 21、Prefixr =css自动添加 -webkit 等私有词缀]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>Sublime Text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[史上最新最全 Markdown 语法大全]]></title>
    <url>%2F2018%2F09%2F23%2F%E5%8F%B2%E4%B8%8A%E6%9C%80%E6%96%B0%E6%9C%80%E5%85%A8-Markdown-%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[###Markdown基础语法 ####标题支持6种大小的标题，分别对应#,##,###,####,#####,######，和样式文件中的h1,...,h6如：12#####H5######H6 ####强调1**我是强调** ####斜体1试试*斜体* ####强调的斜体1试试***强调的斜体*** ####删除1试试 ~~删除~~ ####外链的超链接Markdown 对链接的语法为：[](),如：1[我是外链的超链接](http://www.corkercode.com) ####页内的超链接页内的超链接语法类似外链，只是要在页内增加锚点，如：1[我是页内的超链接](#jump_1) 注：你先要在要跳转的到地方放置一个类似：&lt;a id=&quot;jump_1&quot;&gt;任意内容&lt;/a&gt;的锚点。由id=&quot;jump_1&quot;来匹配。 ####图片显示Markdown 对图片链接的语法是:![](),如：1![图注:zoluo](http://plbhkv0pr.bkt.clouddn.com/wechat-qcode.jpg) 下图为我的公众号，欢饮关注，获取更多编程与互联网那些事儿。注：可直接把网络图片地址添加到markdown中，默认为图片居中，[这里写图片描述]中对图片的描述内容会自动生成在图片的底部。 ####有序列表 有序列表 1 有序列表 2 有序列表 3 ####无序列表 无序列表 1 无序列表 2 无序列表 3 ####引用块只需要在前面加 &gt;,如下: 我是引用块微信公众号：zoluo欢迎关注我，一起学习，一起进步! ####分隔线 ####行内代码Markdown 对行内代码的语法是前后用：`,其中 ` 为 Windows 键盘左上角那个,如：AppCompatActivity类1`AppCompatActivity` ####代码块Markdown 对代码块的语法是开始和结束行都要添加：```,其中 ` 为windows键盘左上角那个，如下：123456789101112131415161718@ApiOperation(&quot;垂深对应值数据中转任务&quot;)@ApiImplicitParams(@ApiImplicitParam(name = &quot;wellState&quot;, required = true, value = &quot;井状态&quot;, paramType = &quot;query&quot;))@GetMapping(value = &quot;verticalDepthTask&quot;)public void verticalDepthTask(String wellState) &#123; List&lt;String&gt; jhList = complexBusinessService.getWellNumListByCondition(wellState); if (null != jhList &amp;&amp; jhList.size() &gt; 0) &#123; for (String jh : jhList) &#123; List&lt;Logging&gt; loggingByWellNum = loggingService.getLoggingByWellNum(jh); if (null != loggingByWellNum &amp;&amp; loggingByWellNum.size() &gt; 0) &#123; loggingService.deleteLoggingByWellNum(jh, 3); for (Logging logging : loggingByWellNum) &#123; verticalDepthService.deleteVerticalDepthByLoggingId(logging.getLoggingId()); &#125; &#125; &#125; complexBusinessService.insertVerticalDepth(jhList); &#125;&#125; 要精确指定语言（如：java,cpp,css,xml,javascript,python,php,go,kotlin,lua,objectivec等等）时，在头部直接指定，如：```javascript， ###Markdown扩展语法 ####表格| 班级 | 男生 | 女生 ||—–|—–|——|| 一(7)班 | 30 | 25 || 一(8)班 | 25 | 30 | 注：表格在公众号预览时，可能在PC端显示的不是正确的全屏，但在手机上预览时就会正常显示为全屏的了。 ####任务列表 [x] 任务1，已完成; [x] 任务2，已完成; [ ] 任务3，未完成; ####注脚我是注脚[^10]。点点就能知到我跳到了那儿。或跳到放置：&lt;a id=&quot;footnote-10&quot;&gt;任意内容&lt;/a&gt;的地方,[^10] 对应id=&quot;footnote-10&quot; ####TOC看内容目录就是用[toc]生成的注：只要放置:[TOC],就能把其后面的标题如：#,##,...######自动生成目录树，注意，[TOC]要独立一行，并前面和后面都要空一行 ###直接支持html,css如果你懂html和css，那下面这些效果就不在话下了： 来个页内跳转，跳转到文未的：&lt;a id=&quot;jump_1&quot;&gt;我是页内跳转到的位置&lt;/a&gt; ,对应：id=&quot;jump_1&quot;先给点颜色你看看再给点颜色你看看试试改变字体大小改变字体大小，再来个粗体又如何？ 试试内容居中 那内容居右呢？ 来个综合的试试第二行1###&lt;span class=&quot;firstletter&quot;&gt;1&lt;/span&gt;试试首字突出 ###Latex数学公式 ####行内公式：$…$是的，我就是行内公式：$e^{x^2}\neq{e^x}^2$，排得OK吗？ ####块公式：$$…$$$$e^{x^2}\neq{e^x}^2$$来个 “复杂点” 的:$$H(D_2) = -(\frac{2}{4}\ log_2 \frac{2}{4} + \frac{2}{4}\ log_2 \frac{2}{4}) = 1$$矩阵：$$ \begin{pmatrix} 1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \ 1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \ 1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n \ \end{pmatrix}$$ 本文参考颜家大少的作品 Md2All . ###赞赏 zoluo如果你觉得到此文章对你有帮助，欢迎赞赏，有你的支持，是我坚持原创的最大动力！]]></content>
      <categories>
        <category>工具集</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web常见错误提示]]></title>
    <url>%2F2018%2F08%2F14%2Fweb%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[在写web程序的时候，经常会出现一些网页错误的数字提示，如果能够明白这些提示的含义，那对于调试程序是有极大帮助的。网上有很多这方面的总结，但为了适应自己的阅读习惯，以及日后的查找方便，就做了一些修改并总结如下。 #HTTP 错误 400 400 请求出错由于语法格式有误，服务器无法理解此请求。不作修改，客户程序就无法重复此请求。 HTTP 错误 401401.1 未授权：登录失败此错误表明传输给服务器的证书与登录服务器所需的证书不匹配。请与 Web 服务器的管理员联系，以确认您是否具有访问所请求资源的权限。 #401.2 未授权：服务器的配置导致登录失败此错误表明传输给服务器的证书与登录服务器所需的证书不匹配。此错误通常由未发送正确的 WWW 验证表头字段所致。请与 Web 服务器的管理员联系，以确认您是否具有访问所请求资源的权限。 #401.3 未授权：由于资源中的 ACL 而未授权此错误表明客户所传输的证书没有对服务器中特定资源的访问权限。此资源可能是客户机中的地址行所列出的网页或文件，也可能是处理客户机中的地址行所列出的文件所需服务器上的其他文件。请记录试图访问的完整地址，并与 Web 服务器的管理员联系以确认您是否具有访问所请求资源的权限。 #401.4 未授权：授权服务被筛选程序拒绝此错误表明 Web 服务器已经安装了筛选程序，用以验证连接到服务器的用户。此筛选程序拒绝连接到此服务器的真品证书的访问。请记录试图访问的完整地址，并与 Web 服务器的管理员联系以确认您是否具有访问所请求资源的权限。 #401.5 未授权：ISAPI/CGI 应用程序的授权失败此错误表明试图使用的 Web服务器中的地址已经安装了 ISAPI 或 CGI程序，在继续之前用以验证用户的证书。此程序拒绝用来连接到服务器的真品证书的访问。 请记录试图访问的完整地址，并与 Web服务器的管理员联系以确认您是否具有访问所请求资源的权限 HTTP 错误 403 #403.1 禁止：禁止执行访问如果从并不允许执行程序的目录中执行 CGI、ISAPI或其他执行程序就可能引起此错误。 如果问题依然存在，请与 Web 服务器的管理员联系。 #403.2 禁止：禁止读取访问如果没有可用的默认网页或未启用此目录的目录浏览，或者试图显示驻留在只标记为执行或脚本权限的目录中的HTML 页时就会导致此错误。如果问题依然存在，请与 Web 服务器的管理员联系。 #403.3 禁止：禁止写访问如果试图上载或修改不允许写访问的目录中的文件，就会导致此问题。 如果问题依然存在，请与 Web服务器的管理员联系。 #403.4 禁止：需要 SSL此错误表明试图访问的网页受安全套接字层（SSL）的保护。要查看，必须在试图访问的地址前输入https:// 以启用 SSL。如果问题依然存在，请与 Web服务器的管理员联系。 #403.5 禁止：需要 SSL 128此错误消息表明您试图访问的资源受 128位的安全套接字层（SSL）保护。要查看此资源，需要有支持此SSL 层的浏览器。请确认浏览器是否支持 128 位 SSL安全性。如果支持，就与 Web服务器的管理员联系，并报告问题。 #403.6 禁止：拒绝 IP 地址 如果服务器含有不允许访问此站点的 IP地址列表，并且您正使用的 IP地址在此列表中，就会导致此问题。如果问题依然存在，请与 Web服务器的管理员联系。 #403.7 禁止：需要用户证书当试图访问的资源要求浏览器具有服务器可识别的用户安全套接字层（SSL）证书时就会导致此问题。可用来验证您是否为此资源的合法用户。请与 Web服务器的管理员联系以获取有效的用户证书。 #403.8 禁止：禁止站点访问如果 Web服务器不为请求提供服务，或您没有连接到此站点的权限时，就会导致此问题。 请与 Web 服务器的管理员联系。 #403.9 禁止访问：所连接的用户太多如果 Web太忙并且由于流量过大而无法处理您的请求时就会导致此问题。请稍后再次连接。 如果问题依然存在，请与 Web 服务器的管理员联系。 #403.10 禁止访问：配置无效此时 Web 服务器的配置存在问题。如果问题依然存在，请与 Web服务器的管理员联系。 #403.11 禁止访问：密码已更改在身份验证的过程中如果用户输入错误的密码，就会导致此错误。请刷新网页并重试。 如果问题依然存在，请与 Web服务器的管理员联系。 #403.12 禁止访问：映射程序拒绝访问 拒绝用户证书试图访问此 Web 站点。请与站点管理员联系以建立用户证书权限。如果必要，也可以更改用户证书并重试。 HTTP 错误 #404 404 找不到Web 服务器找不到您所请求的文件或脚本。请检查URL 以确保路径正确。 如果问题依然存在，请与服务器的管理员联系。 #HTTP 错误 405 405 不允许此方法对于请求所标识的资源，不允许使用请求行中所指定的方法。请确保为所请求的资源设置了正确的 MIME 类型。如果问题依然存在，请与服务器的管理员联系。 #HTTP 错误 406 406 不可接受根据此请求中所发送的“接受”标题，此请求所标识的资源只能生成内容特征为“不可接受”的响应实体。 如果问题依然存在，请与服务器的管理员联系。 #HTTP 错误 407 #407 需要代理身份验证在可为此请求提供服务之前，您必须验证此代理服务器。请登录到代理服务器，然后重试。 如果问题依然存在，请与 Web 服务器的管理员联系。 #HTTP 错误 412 412 前提条件失败在服务器上测试前提条件时，部分请求标题字段中所给定的前提条件估计为FALSE。客户机将前提条件放置在当前资源 metainformation（标题字段数据）中，以防止所请求的方法被误用到其他资源。 如果问题依然存在，请与 Web 服务器的管理员联系。 #HTTP 错误 414414 Request-URI 太长Request-URL太长，服务器拒绝服务此请求。仅在下列条件下才有可能发生此条件： 客户机错误地将 POST 请求转换为具有较长的查询信息的 GET 请求。 客户机遇到了重定向问题（例如，指向自身的后缀的重定向前缀）。服务器正遭受试图利用某些服务器（将固定长度的缓冲区用于读取或执行 Request-URI）中的安全性漏洞的客户干扰。如果问题依然存在，请与 Web 服务器的管理员联系。 #HTTP 错误 500500 服务器的内部错误Web 服务器不能执行此请求。请稍后重试此请求。 如果问题依然存在，请与 Web服务器的管理员联系。 #HTTP 错误 501 501 未实现Web 服务器不支持实现此请求所需的功能。请检查URL 中的错误，如果问题依然存在，请与 Web服务器的管理员联系。 #HTTP 错误 502 502 网关出错当用作网关或代理时，服务器将从试图实现此请求时所访问的upstream 服务器中接收无效的响应。 如果问题依然存在，请与 Web服务器的管理员联系。]]></content>
      <categories>
        <category>Java 编程思想</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客建站六〈彩蛋〉]]></title>
    <url>%2F2018%2F07%2F14%2FHexo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%AD%E3%80%88%E5%BD%A9%E8%9B%8B%E3%80%89%2F</url>
    <content type="text"><![CDATA[最后放个大招，我的 个人博客地址,是不是还可以啊！贴上我的自定义样式代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292// Custom styles.//顶部条.headband &#123; height: 0;&#125;//背景图body &#123; background-image: url(http://plbhkv0pr.bkt.clouddn.com/background.jpg); background-attachment: fixed; // 不随屏幕滚动而滚动fixed,scroll,inherit background-repeat: no-repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺 background-size: cover; // contain等比例铺满屏幕 //cover拉伸铺满 background-position: bottom;//x,y轴调整 +mobile()&#123; //background-position: 0% -20%; background-image: linear-gradient(90deg, #F79533 0%, #F37055 15%, #EF4E7B 30%, #A166AB 44%, #5073B8 58%, #1098AD 72%, #07B39B 86%, #6DBA82 100%); &#125;&#125;//首部背景url(http://plbhkv0pr.bkt.clouddn.com/header.jpg)//彩色linear-gradient(90deg, #F79533 0%, #F37055 15%, #EF4E7B 30%, #A166AB 44%, #5073B8 58%, #1098AD 72%, #07B39B 86%, #6DBA82 100%).site-meta &#123; height: 100px; background-image: url(http://plbhkv0pr.bkt.clouddn.com/header.jpg); background-size: cover;&#125;//侧边栏信息样式修改/*.links-of-blogroll-item &#123; padding: 0 8px; background-color: #50842e; border-radius: 4px;&#125;.links-of-blogroll-item a &#123; color: #fff; border-bottom: none; display: inline;&#125;*///.header-inner &#123; background: rgba(255,255,255,0.7) border-radius: 10px;&#125;//侧栏.sidebar&#123; background: none; border-radius: 10px;&#125;.sidebar-inner &#123; padding: 10px 10px 10px; background: rgba(255,255,255,0.7) border-radius: 10px;&#125;code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125;//夜间模式.cover&#123; position:fixed; top: 0px; left: 0px; outline:5000px solid rgba(0, 0, 0, 0); z-index: 99999;&#125;//沐目体@font-face &#123; font-family: MMT; src: url(&quot;/media/MMT_579767_SOAJ0_0.ttf&quot;);&#125;@font-face &#123; font-family: STLiti; src: url(&quot;/media/STLITI.TTF&quot;);&#125;@font-face &#123; font-family: STXK; src: url(&quot;/media/STXINGKA.TTF&quot;);&#125;//输入框美化input &#123; border: 1px solid #ccc; padding: 5px 0px; border-radius: 3px; padding-left: 5px; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075); -webkit-transition: border-color ease-in-out .15s, -webkit-box-shadow ease-in-out .15s; -o-transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s; transition: border-color ease-in-out .15s, box-shadow ease-in-out .15s&#125;input:focus &#123; border-color: #66afe9; outline: 0; -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 8px rgba(102, 175, 233, .6); box-shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 8px rgba(102, 175, 233, .6)&#125;//文章页内标签样式.posts-expand .post-tags &#123; margin: 40px 10px 0 10px; text-align: right;&#125;.posts-expand .post-tags a &#123; -webkit-box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); -moz-box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); font-family: &apos;Comic Sans MS&apos;, sans-serif; transition: 0.2s ease-out; padding: 3px 5px; margin: 5px; background: #eee; border-bottom: none; border-radius: 15px; &amp;:hover &#123; background: rgba(100,154,182,0.902); color: #fff; -webkit-box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19); -moz-box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19); box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19); &#125;&#125;.tag-cloud a &#123; -webkit-box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); -moz-box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); transition: 0.2s ease-out; padding: 2px 10px; margin: 8px; background: #eee; border-bottom: none; border-radius: 12px; &amp;:hover &#123; text-decoration: none; background: rgba(100,154,182,0.902); color: #fff !important; -webkit-box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19); -moz-box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19); box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2), 0 6px 20px 0 rgba(0,0,0,0.19); &#125;&#125;//文章标题.posts-expand .post-title &#123; font-size: 21px border-left: #649ab6 2px solid; font-weight: bold; padding-left: 10px;&#125;.posts-expand .post-title, .posts-expand .post-meta &#123; text-align: left;&#125;.page-post-detail .post-title, .page-post-detail .post-meta &#123; text-align: center; border-left: none; padding-left: 0;&#125;.posts-expand .post-title-link&#123; line-height: 1.5;&#125;//修改默认按钮样式#bdc3c7.post-button &#123; text-align: right;&#125;.btn &#123; padding: 3px 15px color: #000 !important; background-color: #fff; border: 0px; border-radius: 15px; &amp;:hover &#123; color: #fff !important; background: #34495e; text-decoration: none !important; &#125;&#125;//页码栏.pagination, .pagination .prev, .pagination .next, .pagination .page-number &#123; border:none;&#125;.pagination .page-number.current &#123; border-radius: 14px; background: #34495e;&#125;.pagination &#123; margin: 60px 0 20px;&#125;//去掉图片边框.posts-expand .post-body img &#123; border: 0px;&#125;//文章样式修改.content-wrap &#123; border-radius: 10px; +mobile()&#123; border-radius: 0px; &#125;&#125;// 文章内链接文本样式.post-body p a&#123; color: #7B68EE; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;//文章阴影.post, .page, .post-block &#123; margin-bottom: 40px; padding: 20px 20px 20px; -webkit-box-shadow: 0 0 14px #cacbcb; -moz-box-shadow: 0 0 14px #cacbcb; box-shadow: 0 0 14px #cacbcb; background: rgba(255,255,255,0.6) border-radius: 10px; +mobile()&#123; margin-bottom: 0px; padding: 0px 0px 0px; -webkit-box-shadow: 0 0 0px rgba(255,255,255,0); -moz-box-shadow: 0 0 0px rgba(255,255,255,0); box-shadow: 0 0 0px rgba(255,255,255,0); background: rgba(255,255,255,0) border-radius: 0px; &#125;&#125;.posts-expand .post-eof &#123; display: block; margin: 0px auto 30px; width: 0;&#125;//评论区.comments&#123; padding: 20px 20px 20px; -webkit-box-shadow: 0 0 14px #cacbcb; -moz-box-shadow: 0 0 14px #cacbcb; box-shadow: 0 0 14px #cacbcb; background: rgba(255,255,255,0.7); margin: 0; border-radius: 10px; +mobile()&#123; margin-bottom: 0px; padding: 0px 0px 0px; -webkit-box-shadow: 0 0 0px rgba(255,255,255,0); -moz-box-shadow: 0 0 0px rgba(255,255,255,0); box-shadow: 0 0 0px rgba(255,255,255,0); background: rgba(255,255,255,0) border-radius: 0px; &#125;&#125;]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客建站五〈天阶配置〉]]></title>
    <url>%2F2018%2F07%2F14%2FHexo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E4%BA%94%E3%80%88%E5%A4%A9%E9%98%B6%E9%85%8D%E7%BD%AE%E3%80%89%2F</url>
    <content type="text"><![CDATA[接上一篇地阶配置 ###天阶配置 评论系统Next 主题支持多种评论系统，如：来必力、多说、Valine，这里我使用 Valine，个人感觉使用比较流畅。注册 Leancloud ，我们的评论系统其实是放在 Leancloud 上的，因此首先需要去注册一个账号，Leancloud官网，点我注册。注册完以后需要创建一个应用，名字可以随便起，然后 进入应用-&gt;设置-&gt;应用key，如下：拿到你的appid和appkey之后，打开主题配置文件 搜索 valine，填入appid 和 appkey:12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true appid: ······ appkey: ······ notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mp # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 注：记得在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去 DaoVoice 在线联系(1) 首先到 DaoVoice 注册账号，支持github、微信注册，开启DaoVoice之旅。注册完后登录，进入到 后台管理，点击 应用设置——&gt;安装到网站 查看安装代码和AppID。注：注册时需要邀请码，这里提供一个1e963cbc.(2) 将安装代码添加到/themes/next/layout/_partials/head.swig中:123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; (3) 编辑主题配置文件，再末尾添加如下代码：123# Online contact daovoice: truedaovoice_app_id: b2f59f80 注：这里 DaoVoice 其实可以接入微信接受消息的，但是要求是公众号必须是认证后的，因此个人公众号就急急了！ 分享功能在next主题的官方的文档中发现它自身集成了百度分享的功能，所以决定采用百度了。这里需要用到 ShareSDK 因此我们得注册一下下 ShareSDK注册，获取到我们 appkey修改主题配置文件如下：12345678910#Sharesharesdk: trueshareSDKappkey: cc1fb1a0053a# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.baidushare: type: slide baidushare: true 注：sharesdk 使用起来并不美观，而百度分享现在对 HTTPS 的支持又不友好，所以我放弃了使用这样的分享方式。大家如果觉得我写的文章还不错，就多推荐下就行了。 Hexo 绑定 Https 域名 你的网站的域名是你的网站的第一印象，为你的网站选择一个域名就如同给你自己选择名字一样重要。你不仅需要选择一个跟你息息相关，跟你的网站相配的域名，同时也要容易被搜到并且容易推广。因此 选择一个完美域名的10个建议 送给你。这里我的域名只是暂时随便买了个，等到期了，换一个有印象的，大家别质疑我目前的域名额。 Hexo 配置域名以及 Https 网上教程很杂乱，我 Google 了下，找到了最简洁快速的方式，秒生效，儿豁你！前面我们提到过准备好自己的域名，下面就是配置的重要事项了： (1) 注册netlify账号到 Netlify 注册账号并登录(2) 配置域名点击页面右上角的 New site from Git，再 Create a new site然后选择 GitHub 选择自己username.github.io的仓库，直接 Deploy site。点击 Domain settings 然后点击 Add custom domain，后按照提示输入你的域名如www.corkercode.com，最后 save。(3) 解析域名配置好域名后如下图，在三个红色区域有三条加了黄色感叹号的DNS提示，我们可以点击查看。然后到域名解析处,修改域名CNAME记录,记录值就是你上面点击看到显示的配置值，下面是我的配置当你解析成功后，上面的黄色感叹号提示会消失，且在下方会出现以下标识，代表你配置完了，此时你可以用 Https 访问的网站了。(3) Https 配置成功此时，恭喜你离成功还差半步，如果正常条件下的话，你应该会看到小绿锁（代表配置成功了）。然而一般还差一步，就是你网站内的内容存在不安全地址（就是有 http 的请求，一般是图片之类的），所以我们得修改图床的 HTTPS 配置了，当然你如果是使用的站内图片那就没问题了。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客建站四〈地阶配置〉]]></title>
    <url>%2F2018%2F07%2F14%2FHexo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%9B%9B%E3%80%88%E5%9C%B0%E9%98%B6%E9%85%8D%E7%BD%AE%E3%80%89%2F</url>
    <content type="text"><![CDATA[接上一篇玄阶配置 ###地阶配置这部分的配置由作者们自由选择了，网上有很多方案，这里我采用的是配置起来比较简单的一种，可参考使用。 网站背景这里有两种方式，第一种是 Next 主题自带的动态背景，只需修改主题配置文件即可：12# Canvas-nestcanvas_nest: true 第二种方式就是自己添加背景图片，这种方式的自己写css代码，不过我已经写好了，拿去用就行了，在\themes\next\source\css\_custom目录下，有custom.styl文件，这里可以放置我们自定义的一些样式，我们先添加一个背景图：123456789101112131415161718// Custom styles.//顶部条.headband &#123; height: 0;&#125;//背景图body &#123; background-image: url(http://plbhkv0pr.bkt.clouddn.com/background.jpg); background-attachment: fixed; // 不随屏幕滚动而滚动fixed,scroll,inherit background-repeat: no-repeat; // 如果背景图不够屏幕大小则重复铺，改为no-repeat则表示不重复铺 background-size: cover; // contain等比例铺满屏幕 //cover拉伸铺满 background-position: bottom;//x,y轴调整 +mobile()&#123; //background-position: 0% -20%; background-image: linear-gradient(90deg, #F79533 0%, #F37055 15%, #EF4E7B 30%, #A166AB 44%, #5073B8 58%, #1098AD 72%, #07B39B 86%, #6DBA82 100%); &#125;&#125; 实现 fork me on github在 GitHub Ribbons 或 GitHub Corners 选择一款你喜欢的挂饰，拷贝方框内的代码,如下：将刚刚复制的挂饰代码，添加到/themes/next/layout/_layout.swig文件中，添加位置如下图所示(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下方)：注：挂饰代码的&lt;a href=&quot;https://https://github.com/zoluoc&quot;这个链接改写成自己 GitHub 地址！ 文章末尾添加“文章结束”标记(1) 在路径\themes\next\layout\_macro文件夹中新建passage-end-tag.swig文件;12345//切换到路径_macrocd [_macro路径]//创建passage-end-tag.swig文件touch passage-end-tag.swig (2) 在passage-end-tag.swig添加以下内容，粘贴以下内容后保存:12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;far fa-grin-tongue&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; (3) 打开\themes\next\layout\_macro\post.swig文件，在END POST BODY之后，添加以下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 添加位置如下图：(4) 修改主题配置文件_config.yml，在末尾添加：123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 头像画圆旋转打开/themes/next/source/css/_common/components/sidebar/sidebar-author.styl，添加以下代码： 1234567891011121314151617181920212223242526272829.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; border-radius: 60%; transition: 2.5s all; &#125;.site-author-image:hover &#123; transform: rotate(360deg);&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 修改代码块样式打开\themes\next\source\css\_custom\custom.styl，添加以下代码： 1234567891011121314code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 侧边栏社交小图标设置打开主题配置文件_config.yml，搜索Social，将你有的社交账号前面的#号去，格式为： 1[社交平台名]: [社交地址] || [图标名称] 12345social: GitHub: https://github.com/zoluoc || github 简书: https://www.jianshu.com/u/aa9caab6cf80 || heartbeat # E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google 左侧栏头部使用图片背景打开\themes\next\source\css\_custom\custom.styl，添加以下代码： 123456//首部背景url(http://plbhkv0pr.bkt.clouddn.com/header.jpg).site-meta &#123; height: 100px; background-image: url(http://plbhkv0pr.bkt.clouddn.com/header.jpg); background-size: cover;&#125; 赞赏支持获取微信和支付宝等收款二维码图片，上传到图床或者博客本地\source\uploads目录下在主题配置文件下修改以下代码： 1234567# Rewardreward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: http://plbhkv0pr.bkt.clouddn.com/wechatpay.pngalipay: http://plbhkv0pr.bkt.clouddn.com/alipay.jpg``` 9. 网站底部加上访问量及文章阅读量这个`Next5.0`版本以后就帮我们集成了`busuanzi`统计了，只需修改主题配置文件的`busuanzi_count`属性，如下： busuanzi_count: count values only if the other configs are false enable: true custom uv span for the whole site site_uv: true site_uv_header: 访客数 site_uv_footer: 人次 custom pv span for the whole site site_pv: true site_pv_header: 访问量 site_pv_footer: 次 custom pv span for one page only page_pv: true page_pv_header: 阅读量 page_pv_footer: 次123**注：不蒜子统计的域名过期问题：修改`/theme/next/layout/_third-party/analytics/busuanzi-counter.swig文件`，替换路径为https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js**10. 博客总字数统计切换到更目录，安装以下插件： npm install hexo-wordcount –save123456在`/themes/next/layout/_partials/footer.swig`末尾添加代码：```html&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 注：这里 Markdown 语法必须写 html，不然 Hexo 编译生成时会报错。 文章统计功能安装Hexo插件，参考博客总字数统计编辑主题配置文件，配置如下： 123456post_wordcount: item_text: true wordcount: true min2read: true totalcount: false separated_meta: true 博客图标 Favicon每个网站都有自己的图标，自己的博客当然也不列外，图标可以在网上找，这里提供以下两个网站 easyicon 和 阿里巴巴矢量图标库，当然也可以自己制作。要求是两张图（大：32x32 小：16x16）的矢量图，准备好图片后放在/themes/next/source/images，将默认的两张图片替换掉。命名和默认的一样也可以自己定义。 修改主题配置文件，如果你自定义了图片名字，需要做修改：12345favicon: small: /images/favicon-16x16-next.png medium: /images/favicon-32x32-next.png apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 网页顶部进度加载条编辑主题配置文件，搜索pace，将其值改为ture就可以了，再选择一款你喜欢的样式。 123456789101112131415161718pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal 隐藏底部由Hexo强力驱动、主题–NexT.Mist打开/themes/next/layout/_partials/footer.swig，注释掉相应代码: 12345678910111213141516171819202122232425262728293031//用下面的符号注释，注释代码用下面括号括起来&lt;!-- --&gt;&lt;!--&lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% if theme.footer.powered %&#125; &lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.powered and theme.footer.theme.enable %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&#123;% endif %&#125;&#123;% if theme.footer.theme.enable %&#125; &lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;&#123;% if theme.footer.custom_text %&#125; &lt;div class=&quot;footer-custom&quot;&gt;&#123;# #&#125;&#123;&#123; theme.footer.custom_text &#125;&#125;&#123;##&#125;&lt;/div&gt;&#123;% endif %&#125;--&gt; 博文置顶修改hexo-generator-index插件，把/node_modules/hexo-generator-index/lib/generator.js中代码替换为： 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 文章添加Top值，值越大，越靠前：1234567891011------title: Hexo博客建站一〈基础搭建〉date: 2018-05-15 09:32:37comments: true #是否可评论toc: true #是否显示文章目录categories: &quot;个人博客&quot;tags: - hexotop: 100--- 网站字体大小编辑/themes/next/source/css/_variables/base.styl，搜索$font-size-base，修改为你想要的大小: 12// Font size$font-size-base = 16px 添加侧栏推荐阅读编辑主题配置文件，如下配置即可： 12345678# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Swift 4: https://developer.apple.com/swift/ Objective-C: https://developer.apple.com/documentation/objectivec 站内搜索NexT主题支持集成 Swiftype、微搜索、Local Search 和 Algolia。这里我们采用 Local Search。(1) 安装 hexo-generator-search 和 hexo-generator-searchdb 12npm install hexo-generator-search --savenpm install hexo-generator-searchdb --save (2) 编辑站点配置文件，添加以下内容:123456# hexo-generator-searchdbsearch: path: search.xml field: post format: html limit: 10000 (3) 编辑主题配置文件，设置Local searchenable为ture1234567local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 修改底部标签样式修改\themes\next\layout\_macro\post.swig中文件，搜索rel=&quot;tag&quot;&gt;#，将#替换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;编译重启，可查看效果。 修改文章内链接文本样式修改/themes/next/source/css/_common/components/post/post.styl，在末尾添加CSS样式，如下：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; //原始链接颜色 border-bottom: none; border-bottom: 1px solid #0593d3; //底部分割线颜色 &amp;:hover &#123; color: #fc6423; //鼠标经过颜色 border-bottom: none; border-bottom: 1px solid #fc6423; //底部分割线颜色 &#125;&#125;]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客建站三〈玄阶配置〉]]></title>
    <url>%2F2018%2F07%2F14%2FHexo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E4%B8%89%E3%80%88%E7%8E%84%E9%98%B6%E9%85%8D%E7%BD%AE%E3%80%89%2F</url>
    <content type="text"><![CDATA[接上一篇黄阶配置 ###玄阶配置前面我们已经成功的执行以下步骤（以下步骤全部在主题配置文件中完成，除开有些标识的）： 下载 Next 主题 12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题修改站点配置文件 1theme: next 验证主题 1234hexo cleanhexo ghexo sINFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。以下是我们即将要执行的操作： 选择 Scheme12345# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 这里我使用第五种，修改主题配置文件即可修改成功。 设置菜单菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标。 设定菜单名称和链接，如下： 123456789menu: home: / || home archives: /archives/ || archive categories: /categories/ || th tags: /tags/ || tags about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 设定菜单项的显示文本Next 默认显示的名称是菜单的的英文，如果要使用其他语言，就要修改主题文件下的languages文件夹下的对应语言的yml的配置文件。这里以简体中文为例（修改zh-Hans.yml）： 12345678910menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 设定菜单项对应的图标 123456789menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive commonweal: heartbeat 注：在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的 Font Awesome 图标名字） 的情况下，NexT 将会使用?作为图标。 | 请注意键值（如 home）的大小写要严格匹配。 设置左侧栏 设置侧栏的位置，修改 sidebar.position 的值，支持的选项有：left - 靠左放置right - 靠右放置 12sidebar: position: left 设置侧栏显示的时机，修改 sidebar.display 的值，支持的选项有：post - 默认行为，在文章页面（拥有目录列表）时显示always - 在所有页面中都显示hide - 在所有页面中都隐藏（可以手动展开）remove - 完全移除 12sidebar: display: post 头像设置主要就是设置头像的路径地址，这里头像的地址可以由多种方式： 地址 值 完整的互联网 URI http://example.com/avatar.png 站点内的地址 将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在） 配置为：avatar: /uploads/avatar.png或者 放置在 source/images/ 目录下配置为：avatar: /images/avatar.png |头像设置示例： 1avatar: http://example.com/avatar.png]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客建站二〈黄阶配置〉]]></title>
    <url>%2F2018%2F07%2F14%2FHexo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E4%BA%8C%E3%80%88%E9%BB%84%E9%98%B6%E9%85%8D%E7%BD%AE%E3%80%89%2F</url>
    <content type="text"><![CDATA[至上篇搭建博客文章后，断更了后续，在此说声抱歉。由于后面的配置篇在网上较为冗余，我把自己的配置过程做了详细记录，其中借鉴了些其他作者的思路，也感谢 Hexo 及 Next 给我们提供这么好的平台。由于本篇幅较长，本着长时间查看不方便，还是分下篇，由天、地、玄、黄四篇配置组成，配置由高到低，博友们可选择配置自己的站点。欢迎关注的我的公众号 zoluo 及博客 zoluo！ 在上一篇文章 Hexo博客建站一〈基础搭建〉 我们已经在本地搭建好了博客的整体框架，接下来，我们应该把文章部署到外网可访问的位置，毕竟只是在本地玩玩就没意思了。 ###Hexo 部署到 GitHub Page在上篇文章我们已经在 GitHub 上创建好了名为 username.github.io 的仓库，下载我们只需按照提示上传我们生成的静态代码到此仓库就行了。在此先声明两点： 站点配置文件_config.yml位于最外层文件夹下 主题配置文件_config.yml位于最外层文件夹/themes/next/_config.yml。 Hexo 配置 GitHub在站点配置文件下，修改以下配置，如： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:zoluoc/zoluoc.github.io.git branch: master SSH配置ssh配置主要是上传代码时hexo d免输用户名和密码，因此有必要配置以下。(1) 首先打开命令行工具，通常我们可以直接右键鼠标任意位置打开 Git Bash Here，然后输入以下命令： 12$ cd ~/.ssh# Checks to see if there is a directory named &quot;.ssh&quot; in your user directory (2) 使用 ssh-keygen 生成密钥1234$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;# Creates a new ssh key using the provided emailGenerating public/private rsa key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa): 简化流程的话在键入命令ssh-keygen -t rsa -C &quot;your_email@example.com&quot;以后的三次提示输入都可以直接回车跳过。密钥生成成功,如：1234Your identification has been saved in /home/you/.ssh/id_rsa.Your public key has been saved in /home/you/.ssh/id_rsa.pub.The key fingerprint is:…………………此处是密钥内容…………………… your_email@example.com (3) 设置此仓库的 SSH keys按下图找到 GitHub 设置 SSH 的位置然后将生成的 id_rsa.pub 中的内容全选复制到 key 输入框中，然后点击 Add key 完成添加公钥。(4) 测试配置是否成功如果出现以下内容即表示配置完成并且成功！123ssh -T git@github.comHi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 这个时候我们再使用hexo d就能上传代码到服务器了！ ####上传代码1hexo d 到 GitHub 仓库可以看到我们的代码已经上传成功。最后我们访问 https://username.github.io 就可以访问到我们的站点了，是不是很6，这不算啥，接下来我们让网站变的更炫酷！ ###黄阶配置以下配置都是修改站点配置文件_config.yml来完成的，参考 Hexo 官网 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言，中文使用zh-Hans timezone 网站时区。Hexo 默认使用您电脑的时区，可不填。时区列表。比如说：America/New_York, Japan, 和 UTC 网址 参数 描述 默认值 url 网址 root 网站根目录 / permalink 文章的永久链接格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 注：这里根目录的设置其实就是把网站放入到子目录，如：将根目录修改成/blog/，则 URL 后须加上/blog。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径 source 注：如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值，到需要时可后续来修改。 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置 创建 Menu 菜单这里主题默认只有两个菜单：首页和归档，因此我们得创建自己的菜单，一下是创建方法：123hexo new page &quot;tags&quot;hexo new page &quot;categories&quot;hexo new page &quot;about&quot;]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客建站一〈基础搭建〉]]></title>
    <url>%2F2018%2F05%2F15%2FHexo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E4%B8%80%E3%80%88%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA%E3%80%89%2F</url>
    <content type="text"><![CDATA[搭建个人博客前面提到了有很多种，我采用的是 Hexo 静态博客，Next 主题。在这里 Hexo Next 就不做详细介绍了，官网地址戳这里 Hexo Next官方网站对安装与配置进行了详细的介绍，包括站点配置主题配置，后面我针对需要的部分进行配置与说明。下面是我搭建的详细过程。 准备工作 电脑以及拥有可用的系统，可上网，Windows、Linux、Mac Os 都可以 Git客户端安装Git 客户端下载点击安装，安装完成如下图 Node.js安装 Node 下载点击安装，安装完成如下图 远程代码仓库 Github、Coding都行，这里我选择Github 这里需注意仓库名必须是 username.github.io 可解析域名准备一个，暂时没有的可不用，我自己买了一个国际域名 corkercode.com 开始安装hexo安装官网上已经有详细的安装说明了，这里记录下关键必须的步骤。当以上所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo，以下所有步骤都在自己建的目录下进行。1npm install hexo --save 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。12hexo initnpm install 新建完成后，指定文件夹的目录如下：这个时候你运行以下命令就可以看到博客框架已搭建起来了访问 博客主页。12hexo ghexo s next安装可以看到上面博客主题不是自己喜欢的样子，别着急，github上给我提供了很多主题样式，地址在这里，自己选择，配置大同小异，我选用next。在终端窗口下，定位到 Hexo 站点目录下。使用 Git checkout 代码：1git clone https://github.com/iissnan/hexo-theme-next themes/next 这时在本地终端上Ctrl+c，结束正在运行的进程，并修改站点配置文件主题为next重新执行上面的命令，可以看到成功的切换到了我们喜欢的主题了。但是和别人的主题比起来还是有一些逊色，不着急，这些都是可以一步一步的配置的，不过我这里注重原创内容创造，对内容上面的配置会更加注重，后面我也会尽量添加一些样式的配置，大家可参考参考。]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客]]></title>
    <url>%2F2018%2F05%2F14%2F%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建个人博客的想法作为一个程序员时不时会看到和想到一些好的文章和观点，有时候还有些漂亮的代码段，想记录下来的方式很多，以前本人使用印象笔记来记录点滴。直到2017年初有了建立博客的想法，最开始自己想使用 Java web 来开发一个 Blog 以及后台管理，v1.0.0 版本也发布出来了，但是个人感觉丑死了，后台使用包 Bootstrap 还好一些，而且没有评论和计数的功能，所以就放弃使用了。后来在网上找了一些第三方的静态 Blog 搭建的方案，最后还是确定使用 Hexo 静态博客和 Next 主题来搭建。 搭建博客的方式搭建博客的方式有很多种，网上也有很多实例如 Wordpress、Z-blog等，我看了几种感觉都感觉不是很合适，最后看到的 Hexo 搭配 GitHub Pages搭建静态博客网站感觉还是挺好的，有很多主题可自己选择，还有很多插件也可以安装，所以就选择了这种方式来搭建我的个人博客。由于搭建博客的过程听起来简单但还是对于一些新人或非程序员来说还是有些不便，后面我会出一个系列文章来指导大家——如何搭建出优美的个人博客。 搭建博客的目的时间不等人，知识学了会忘，blog 不仅可以记录你生活的点滴还能帮助你成长，能让别人来见证你的过程，还能帮助别人解决困难……所以我决定开始属于自己的 Blog。后面我会不定时的更新博客内容，诚邀大家一起指点记录 zoluo.]]></content>
      <categories>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
